---
title: "Evaluating regional variation in neighbourhood socioeconomic inequalities in motor-vehicle injury collisions - R Code"
author: "Michael Branion-Calles"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
editor_options: 
  chunk_output_type: console
---

# Load Libraries and Functions

```{r libraries and functions,message=FALSE}

tictoc::tic()

# Load fonts (run this once)
# font_import()  # Uncomment if you haven't done this yet
# loadfonts(device = "win")
library(extrafont)
library(cowplot)
library(hrbrthemes)
library(INLA)         
library(tidyverse)  
library(sf)
library(sp)            
library(spdep)         
library(flextable)     
library(RColorBrewer)  
library(rcartocolor)   
library(janitor)       
library(broom)
library(ggspatial)
library(ggridges)
library(officer)
library(leaflet)
library(htmlwidgets)
# remotes::install_github("inbo/inlatools")
library(inlatools)


# Functions ---------------------------------------------------------------

# Standardize a numeric vector
my_std <- function(x) { (x - mean(x,na.rm=TRUE)) / sd(x,na.rm = TRUE)}

# Function to create a comparison table for multiple INLA models
# Takes a list of INLA models and optional model names as input
# Returns a wide-format table with parameter estimates and model fit criteria
create_inla_comparison_table <- function(model_list, model_names = NULL) {

  # Set up model names: either use provided names or generate sequential names (m1, m2, etc.)
  if (is.null(model_names)) {
    model_names <- paste0("m", seq_along(model_list))
  } else {
    # Validate that number of names matches number of models
    if (length(model_names) != length(model_list)) {
      stop("Number of model names must match number of models")
    }
    # Clean names to be R friendly (removes special characters, spaces)
    model_names <- make.names(model_names, unique = TRUE)
    # Replace dots with underscores for consistent naming
    model_names <- gsub("\\.", "_", model_names)
  }
  
  # Initialize empty lists to store different types of parameters
  fixed_effects <- list()      # For fixed effects coefficients
  model_criteria <- list()     # For model fit criteria (DIC, WAIC)
  hyperparameters <- list()    # For model hyperparameters
  
  # Extract information from each model in the list
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]
    current_model_name <- model_names[i]
    
    # Extract fixed effects estimates and credible intervals
    fe <- data.frame(
      term = rownames(model$summary.fixed),
      model = current_model_name,
      parameter_type = "fixed_effect",
      mean = model$summary.fixed[, "mean"],
      lower = model$summary.fixed[, "0.025quant"],  # 2.5% quantile
      upper = model$summary.fixed[, "0.975quant"]   # 97.5% quantile
    )
    fixed_effects[[i]] <- fe
    
    # Extract model fit criteria (DIC and WAIC)
    dic <- model$dic$dic
    waic <- model$waic$waic
    model_criteria[[i]] <- data.frame(
      term = c("dic", "waic"),
      model = current_model_name,
      parameter_type = "model_fit",
      mean = c(dic, waic),
      lower = NA,    # No CI for model fit criteria
      upper = NA
    )
    
    # Extract hyperparameters if they exist
    if (!is.null(model$summary.hyperpar)) {
      hyper <- data.frame(
        term = rownames(model$summary.hyperpar),
        model = current_model_name,
        parameter_type = "hyperparameter",
        mean = model$summary.hyperpar[, "mean"],
        lower = model$summary.hyperpar[, "0.025quant"],
        upper = model$summary.hyperpar[, "0.975quant"]
      )
      hyperparameters[[i]] <- hyper
    }
  }
  
  # Combine all parameters into one table and reshape to wide format
  all_params <- bind_rows(
    do.call(rbind, fixed_effects),
    do.call(rbind, model_criteria),
    do.call(rbind, hyperparameters)
  ) %>%
    # Convert to wide format: separate columns for each model's estimates
    pivot_wider(
      id_cols = c(term, parameter_type),
      names_from = model,
      names_glue = "{model}_{.value}",  # Creates columns like "m1_mean", "m1_lower", etc.
      values_from = c(mean, lower, upper)
    ) %>%
    # Sort by parameter type
    arrange(parameter_type)
  
  # Create desired column order: term, parameter_type, then grouped by model
  col_order <- c("term", "parameter_type")
  for (model_name in model_names) {
    col_order <- c(
      col_order,
      paste0(model_name, "_mean"),
      paste0(model_name, "_lower"),
      paste0(model_name, "_upper")
    )
  }
  
  # Reorder columns according to specified order
  all_params <- all_params %>%
    select(all_of(col_order))
  
  return(all_params)
}

# Function calculates Incident Rate Ratios (IRR) for each region based on posterior samples
# For each region, IRR is calculated as exp(base effect + region interaction effect)
# where base effect is vandix_z and region interaction is vandix_z:region
# IRRs are derived from the posterior distribution of these summed effects
# Returns tibble with posterior samples and summary statistics (mean, 95% CI) by region
vandix_irr <- function(m.samp) {
 # Calculate base IRR (reference region - Vancouver)
 fun <- function()
   return (exp(vandix_z))
 van <- inla.posterior.sample.eval(fun, m.samp)
 
 # Calculate IRR for Victoria region
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionVictoria`))
 vic <- inla.posterior.sample.eval(fun, m.samp)
 
 # Calculate IRR for Okanagan region
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionOkanagan`))
 ok <- inla.posterior.sample.eval(fun, m.samp)
 
 # Central Island
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionCentral Island`))
 ci <- inla.posterior.sample.eval(fun, m.samp)
 
 # Northeast
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionNortheast`))
 ne <- inla.posterior.sample.eval(fun, m.samp)
 
 # Kamloops
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionKamloops`))
 ka <- inla.posterior.sample.eval(fun, m.samp)
 
 # Campbell River
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionCampbell River`))
 cr <- inla.posterior.sample.eval(fun, m.samp)
 
 # Parksville
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionParksville`))
 pa <- inla.posterior.sample.eval(fun, m.samp)
 
 # Cranbrook
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionCranbrook`))
 cb <- inla.posterior.sample.eval(fun, m.samp)
 
 # Squamish
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionSquamish`))
 sq <- inla.posterior.sample.eval(fun, m.samp)
 
 # Terrace
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionTerrace`))
 te <- inla.posterior.sample.eval(fun, m.samp)
 
 # Salmon Arm
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionSalmon Arm`))
 sa <- inla.posterior.sample.eval(fun, m.samp)
 
 # Nelson
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionNelson`))
 ns <- inla.posterior.sample.eval(fun, m.samp)
 
 # Powell River
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionPowell River`))
 pri <- inla.posterior.sample.eval(fun, m.samp)
 
 # Trail
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionTrail`))
 tr <- inla.posterior.sample.eval(fun, m.samp)
 
 # Prince Rupert
 fun <- function()
   return (exp(vandix_z + `vandix_z:regionPrince Rupert`))
 pr <- inla.posterior.sample.eval(fun, m.samp)
 
 # Create tibble with results for all regions
 vandix_irr_by_region <- tibble(
   region = region_levels,
   vandix_irr_post = list(van, vic, ok, ci, ne, ka, cr, pa, cb, sq, te, sa, ns, pri, tr, pr)
 ) %>%
   mutate(
     irr_mean = map_dbl(vandix_irr_post, ~ mean(.x)),
     irr_low  = map_dbl(vandix_irr_post, ~ quantile(.x, probs = c(0.025))),
     irr_high = map_dbl(vandix_irr_post, ~ quantile(.x, probs = c(0.975)))
   )
 
 return(vandix_irr_by_region)
}


```

# Load Data and Clean

```{r clean data,message=FALSE}

# Read spatial data for dissemination areas in British Columbia
bc_boundary <- st_read(
  "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Processed Data/da_v4_2021c.gpkg"
) %>% 
  st_union()

cma_da <- st_read(
  "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Processed Data/da_v4_2021c.gpkg"
) %>%
  mutate(cma_name = ifelse(
    str_detect(cmaname, "metropolitan influenced zone"),
    NA_character_,
    cmaname
  )) %>%
  rename(population = population_2021) %>%
  filter(!is.na(cma_name)) %>%  # Filter out rows without CMA names
  mutate(
    population_100 = population / 100,    # Scale population down by factor of 100
    population_100_c = scale(population_100, scale = FALSE),    # Center population
    total_lane_length_km = adjusted_lane_length_m / 1000,     # Convert total length of all lanes of road from meters to kilometers
    # Calculate casualty claims rates per kilometer of road
    n_casualty_claims_rate = n_casualty_claims / total_lane_length_km * 10,
    n_pedestrian_casualty_claims_rate = n_pedestrian_casualty_claims / total_lane_length_km * 10,
    n_cyclist_casualty_claims_rate = n_cyclist_casualty_claims / total_lane_length_km * 10,
    
    # Calculate the proportion of roads that are highways or arterials
    roads_prop_highway_arterial = (
      adjusted_lane_length_m_highway + adjusted_lane_length_m_arterial
    ) / adjusted_lane_length_m,
    roads_prop_highway_arterial_z = my_std(roads_prop_highway_arterial),
    # Standardize the proportion
    
    # Log-transform the total length of roads in kilometers
    ln_roads_km = ifelse(total_lane_length_km == 0, NA, log(total_lane_length_km)),
    ln_roads_km_c = scale(ln_roads_km, scale = FALSE),
    # Center log-transformed roads
    
    # Calculate casualty claims rates by total road kilometers
    casualty_claims_rate = n_casualty_claims / total_lane_length_km * 10,
    cyclist_casualty_claims_rate = n_cyclist_casualty_claims / total_lane_length_km * 10,
    pedestrian_casualty_claims_rate = n_pedestrian_casualty_claims / total_lane_length_km * 10,
    
    intersection_density_z = my_std(intersection_density),
    #
    
    number_intersections_10_c = scale(number_intersections / 10, scale = FALSE),
    # Center log-transformed roads
    
    # Convert CANBICS class to descriptive categories
    canbics_class_c = case_when(
      canbics_class == 1 | canbics_class == "2" ~ "1 - Low",
      canbics_class == 5 | canbics_class == "4" ~ "3 - High",
      canbics_class == 3 ~ "2 - Medium"
    ),
    canbics_index_z = my_std(canbics_index),
    # Standardize CANBICS index
    
    # bike_infra_cat = factor(ifelse(bike_infra==1,"Yes","No"),levels = c("No","Yes")),
    # bike_infra_km = km_high_comfort_bike_infra + km_med_comfort_bike_infra + km_low_comfort_bike_infra,
    # bike_infra_km_c = scale(bike_infra_km, scale = FALSE),  # Center log-transformed roads
    
    bike_infra_cat = factor(any_bike_infra, levels = c("No", "Yes")),
    bike_infra_km_c = scale(total_bike_infra_m/1000, scale = FALSE),
    # Center log-transformed roads
    
    home_owner_prevalence = owner  /
      total_private_households_by_tenure_25_percent_sample_data ,
    
    no_highschool_prevalence = no_certificate_diploma_or_degree /
      total_highest_certificate_diploma_or_degree_for_the_population_aged_15_years_and_over_in_private_households_25_percent_sample_data ,
    
    university_degree_prevalence = postsecondary_certificate_diploma_or_degree /
      total_highest_certificate_diploma_or_degree_for_the_population_aged_15_years_and_over_in_private_households_25_percent_sample_data,
    
    lone_parent_fam_prevalence = total_one_parent_families / total_number_of_census_families_in_private_households_100_percent_data,
    
    
    # Calculate VanDIX score based on various factors
    z_no_highschool_prevalance_w = scale(no_highschool_prevalence),
    z_university_degree_prevalance_w = scale(university_degree_prevalence * -1),
    z_unemployment_rate_w = scale(unemployment_rate),
    z_lone_parent_fam_prevalence_w = scale(lone_parent_fam_prevalence),
    z_hh_avg_income_w = scale(average_total_income_of_household_in_2020 * -1),
    z_home_owner_prevalence_w = scale(home_owner_prevalence * -1),
    z_participation_rate_w = scale(participation_rate * -1),
    
    # Compute VanDIX (Area Level Deprivation Index) score
    vandix = as.numeric(
      z_hh_avg_income_w * 0.089 +
        z_home_owner_prevalence_w * 0.089 +
        z_lone_parent_fam_prevalence_w * 0.143 +
        z_no_highschool_prevalance_w * 0.25 +
        z_university_degree_prevalance_w * 0.179 +
        z_unemployment_rate_w * 0.214 +
        z_participation_rate_w * 0.036
    ), 
    
    vandix_z = my_std(vandix),
    
    region_name = case_when(
      cma_name %in% c("Prince Rupert", "Terrace") ~ "Northwest",
      cma_name %in% c(
        "Fort St. John",
        "Dawson Creek",
        "Prince George",
        "Quesnel",
        "Williams Lake"
      ) ~ "North Central",
      cma_name %in% c("Kamloops", "Salmon Arm") ~ "Kamloops-Salmon Arm",
      cma_name %in% c("Vernon", "Kelowna", "Penticton") ~ "Okanagan",
      cma_name %in% c("Cranbrook", "Nelson", "Trail") ~ "Southeast",
      cma_name %in% c("Vancouver", "Squamish") ~ "Vancouver-Squamish",
      cma_name %in% c("Abbotsford - Mission", "Chilliwack") ~ "Fraser Valley",
      cma_name %in% c(
        "Campbell River",
        "Courtenay",
        "Port Alberni",
        "Parksville",
        "Nanaimo",
        "Ladysmith",
        "Duncan",
        "Powell River"
      ) ~ "Central Island-Powell River",
      cma_name == "Victoria" ~ "Victoria",
      TRUE ~ NA_character_  # Handle cases where CMA name doesn't match any of the specified values
    )
  )


regions <- cma_da %>%
  st_drop_geometry() %>%
  group_by(region_name) %>% 
  summarise(n = n(),
            CMAs = paste0(unique(cma_name),collapse = ";" ),
            n_casualty_claims = sum(n_casualty_claims,na.rm=TRUE),
                        n_cyclist_casualty_claims = sum(n_cyclist_casualty_claims,na.rm=TRUE),
            n_pedestrian_casualty_claims = sum(n_pedestrian_casualty_claims,na.rm=TRUE),
            population = sum(population,na.rm=TRUE)) %>% 
  
  arrange(desc(population)) %>% 
  remove_missing() 



cma_da <- cma_da %>% 
 mutate(region_name = factor(region_name, levels = regions$region_name))


cma_da <- cma_da %>% 
  filter(total_lane_length_km>0) %>% #filter out DAs without any roads 
  filter(!is.na(vandix_z)) #filter out DAs missing deprivation score

csd <- cma_da %>% 
    st_drop_geometry() %>% 
  group_by(csduid) %>% 
  tally(sort=TRUE)

types <- c("IRI","RDA","CY","DM","VL","T","S-É","IGD","IM","NL","RGM","TAL","TWL")

csd_type <- cancensus::get_census(dataset='CA21', regions=list(PR="59"), 
                          vectors=c("v_CA16_408","v_CA16_409","v_CA16_410"), level='CSD') %>%  
  mutate(
    Type = str_extract(`Region Name`, paste(types, collapse = "|")),
    Name = str_remove(`Region Name`, paste0(" \\(", Type, "\\)")),
  csduid = GeoUID  %>% as.numeric())

csd %>% 
  left_join(csd_type) %>% 
  group_by(Type) %>% 
  summarise(n = n(),
            min_pop = min(Population),
            pop = sum(Population),
            max_pop = max(Population),
            mean_pop = pop/n) %>% 
  arrange(desc(pop))

```

## Variance in estimated counts through randomization

```{r, fig.height=12.75591,fig.width=10.09843}

claims_da_join <-  read_csv(file = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Processed Data/intersection_base_claimscasualty_crash.csv") %>%
  mutate(dauid = as.character(dauid))

random_assignment <-  read_csv(file = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Processed Data/intersection_remainder_assignmentcasualty_crash.csv") %>%
  mutate(dauid = as.character(dauid))

base <- claims_da_join %>% 
    filter(dauid %in% cma_da$dauid) %>% # dauid's included
    # Sum up base claims per DA (the evenly distributed portion)
    group_by(dauid,n_intersections) %>% 
    summarise(base_claims = sum(base_claims)) 

claims_on_border <- claims_da_join %>% 
      filter(dauid %in% cma_da$dauid) %>% # dauid's included
  filter(n_intersections>1) %>% 
  summarise(base_claims=sum(base_claims))


claims_not_on_border <- claims_da_join %>% 
    filter(dauid %in% cma_da$dauid) %>% # dauid's included
    filter(n_intersections==1) %>% 
  summarise(base_claims=sum(base_claims))

claims_on_border_random_assign <- random_assignment %>% 
      filter(dauid %in% cma_da$dauid)

sum(claims_on_border$base_claims) + sum(claims_not_on_border$base_claims) + sum(claims_on_border_random_assign$remainder_claims) == sum(cma_da$n_casualty_claims)
  

sum(claims_on_border$base_claims) / (sum(claims_on_border$base_claims) + sum(claims_not_on_border$base_claims) + sum(claims_on_border_random_assign$remainder_claims)) * 100 # percent of injuries on border of at least two DAs evenly distributed

sum(claims_on_border_random_assign$remainder_claims) / (sum(claims_on_border$base_claims) + sum(claims_not_on_border$base_claims) + sum(claims_on_border_random_assign$remainder_claims)) * 100 # percent of injuries on border that are randomly assigned (does not go evenly into bordering DAs)

sum(claims_not_on_border$base_claims) / (sum(claims_on_border$base_claims) + sum(claims_not_on_border$base_claims) + sum(claims_on_border_random_assign$remainder_claims)) * 100 # percent of injuries on border of at least two DAs evenly distributed



######### Variation in counts due to random assignment

n_casualty_claims_iteration <- readRDS( "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Processed Data/iterate_casualty_claims.rds")

casualty_claims_total_variance <- map(n_casualty_claims_iteration,~right_join(.x,cma_da %>% st_drop_geometry(.)) %>% 
                                        replace_na(list(total_claims =0)))
  
  
casualty_claims_total_variance <- casualty_claims_total_variance %>% 
    bind_rows(.id = "iteration") %>%
  group_by(dauid) %>%
  summarise(
    # For n_casualty_claims
    n = n(),
    min_n_casualty = min(total_claims),
    max_n_casualty = max(total_claims),
    range = max_n_casualty - min_n_casualty,
    iqr = IQR(total_claims),
  )

casualty_claims_total_variance %>% 
  summarise(n = n(),
            median_range = median(range),
            q25 = quantile(range,probs = 0.25),
            q75 = quantile(range,probs = 0.75)
            )

casualty_claims_total_variance %>%
  ggplot(aes(x=range))+
  geom_histogram(color = "black",fill = "#257D98",binwidth = 1)+
  scale_fill_carto_d(name = "Quartiles", palette = "Geyser") + 
  theme_ipsum_es(axis_title_size = 12,
                 grid = "XxYy",
                 ticks = TRUE) +
  scale_x_continuous(breaks = c(seq(0,10,by = 2)),
                     labels = c(seq(0,10,by = 2)))+ 
  ylab("Number of DAs") +
  xlab("Range in Estimated Counts") + 
  labs(title="Distribution of range in motor-vehicle injury crashes across 50 simulated datasets for all DAs")



```


# Spatial Models

### Setting up Spatial Weights Matrix

```{r spatial weights matrix, fig.height=10,fig.width=10}

#### Define Spatial Neighborhoods and Connect Disconnected Regions ####

# Convert sf object to sp object for compatibility with spdep package
cma_sp <- as(cma_da, "Spatial")
#  Get centroids of polygons
coords <- coordinates(cma_sp) 
# Create neighborhood list using queen contiguity (shared vertices or edges)
cma_nb <- poly2nb(cma_sp, queen = TRUE)
# Display neighborhood structure
summary(cma_nb)

# Read in road network data, focusing on bridges
bridges_sub <- #road network polyline
  st_read(dsn = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Processed Data/dra_briges_tunnels.gpkg")

# library(mapview)
# mapview(bridges_sub) + mapview(cma_da)

# Find which DAs intersect with bridges (with 1m buffer)
bridge_da_intersect <- cma_da %>%
  mutate(index = row_number()) %>%
  st_join(st_buffer(bridges_sub,1), join = st_intersects) %>% 
    filter(!is.na(TRANSPORT_LINE_ID))

# mapview(cma_da) + mapview(bridge_da_intersect,color="red") + mapview(bridges_sub) 


# Create pairs of DA indices connected by bridges
bridge_neighbours <- bridge_da_intersect %>% 
  group_by(STRUCTURED_NAME_1) %>% 
  summarise(
    index = paste0(sort(unique(index)), collapse = "-"),
    .groups = "drop"
  ) %>%
    # Split bridge connections into separate columns
  separate_wider_delim(
    cols = index,
    delim = "-",
    names_sep = "_",
    too_few = "align_start",
    too_many = "drop"
  ) %>% 
  filter(!is.na(index_2)) # remove bridges that connect a neighbourhood to itself

# Convert bridge connections to list format
bn_l <- bridge_neighbours %>% 
  pivot_longer(cols = starts_with("index"),values_to = "index") %>% 
  filter(!is.na(index)) %>% 
  split(.$STRUCTURED_NAME_1) %>% 
  map(~pull(.x,index)) %>% 
  map(~as.integer(.x))

for(i in 1:length(bn_l)){
  
for(j in 1:length(bn_l[[i]]))
  # Add bridge connections to neighborhood list
  index <- bn_l[[i]][j]
  nbs_add <-  bn_l[[i]][-j]

    cma_nb <- addlinks1(cma_nb,from = index, to = nbs_add)

  
}

###### Add Manual Connections
cma_nb

### Bowen Island - Horseshoe bay 

cma_nb <- addlinks1(cma_nb,from = 625,to = 3570)

### Horseshoe Bay - Lions Bay
cma_nb <- addlinks1(cma_nb,from = 625,to = 3483)

### Courtenay  - Denman
cma_nb <- addlinks1(cma_nb,from = 5166,to = 5168)


### Courtenay  - Denman
cma_nb <- addlinks1(cma_nb,from = 5168,to = 5170)

# Check updated neighborhood structure
summary(cma_nb)

updated_components <- spdep::n.comp.nb(cma_nb)

cma_da$disconnected_region <- factor(as.character(updated_components$comp.id),levels = as.character(c(seq(1:updated_components$nc))))

# colors_16 <- c(
#     "#e41a1c",  # red
#     "#377eb8",  # blue
#     "#4daf4a",  # green
#     "#984ea3",  # purple
#     "#ff7f00",  # orange
#     "#ffff33",  # yellow
#     "#a65628",  # brown
#     "#f781bf",  # pink
#     "#999999",  # grey
#     "#66c2a5",  # mint
#     "#fc8d62",  # salmon
#     "#8da0cb",  # light blue
#     "#e78ac3",  # rose
#     "#a6d854",  # lime
#     "#ffd92f",  # gold
#     "#e5c494"  # tan
# 
# )
# 
# mapview::mapview(cma_da, 
#                 zcol = "disconnected_region",
#                 col.regions = colors_16)

# cma_da %>%
#   st_drop_geometry() %>%
#   group_by(disconnected_region) %>%
#   summarise(csdname = paste0(unique(csdname), collapse = "-")) %>%
#   print(n = 100) %>%
#   mutate(region = case_when(disconnected_region == 1 ~ "Cranbrook",
#                               disconnected_region == 2 ~ "Nelson",
#                               disconnected_region == 3 ~ "Trail",
#                               disconnected_region == 4 ~ "Okanagan",
#                               disconnected_region == 5 ~ "Vancouver-Fraser Valley",
#                               disconnected_region == 6 ~ "Victoria",
#                               disconnected_region == 7 ~ "Central Island",
#                               disconnected_region == 8 ~ "Parksville",
#                               disconnected_region == 9 ~ "Campbell River",
#                               disconnected_region == 10 ~ "Powell River",
#                               disconnected_region == 11 ~ "Squamish",
#                               disconnected_region == 12 ~ "Kamloops",
#                               disconnected_region == 13 ~ "Salmon Arm",
#                               disconnected_region == 14 ~ "Northeast",
#                               disconnected_region == 15 ~ "Prince Rupert",
#                               disconnected_region == 16 ~ "Terrace"
# 
#                               )
#          ) %>% View()

# Assign meaningful region names to subgraphs
cma_da <- cma_da %>%
  mutate(region = case_when(disconnected_region == 1 ~ "Cranbrook",
                              disconnected_region == 2 ~ "Nelson",
                              disconnected_region == 3 ~ "Trail",
                              disconnected_region == 4 ~ "Okanagan",
                              disconnected_region == 5 ~ "Vancouver-Fraser Valley",
                              disconnected_region == 6 ~ "Victoria",
                              disconnected_region == 7 ~ "Central Island",
                              disconnected_region == 8 ~ "Parksville",
                              disconnected_region == 9 ~ "Campbell River",
                              disconnected_region == 10 ~ "Powell River",
                              disconnected_region == 11 ~ "Squamish",
                              disconnected_region == 12 ~ "Kamloops",
                              disconnected_region == 13 ~ "Salmon Arm",
                              disconnected_region == 14 ~ "Northeast",
                              disconnected_region == 15 ~ "Prince Rupert",
                              disconnected_region == 16 ~ "Terrace"
                              )
         )
# Set region factor levels based on population order
region_levels <- cma_da %>% 
  st_drop_geometry() %>% 
  group_by(region) %>% 
  summarise(pop = sum(population)) %>% 
  arrange(desc(pop)) %>% 
  pull(region)

cma_da <- cma_da %>% 
  mutate(region = factor(region,region_levels))

# Final conversion to sp object and add unique identifier
cma_sp <- as(cma_da, "Spatial")
cma_sp$ui <- 1:nrow(cma_sp@data)

cma_da %>% 
  st_drop_geometry() %>% 
  summarise(median_pop = median(population),
            q25 = quantile(population, 0.25),
            q75 = quantile (population, 0.75)
            )
            

```

### Spatial Dependency in each crash type

```{r spatial clustering}

# Convert neighborhood list to spatial weights matrix
listw <- nb2listw(cma_nb)

# Test for spatial autocorrelation in all casualty claims
# Null hypothesis: no spatial autocorrelation
all_cc_mi <- moran.mc(cma_da$n_casualty_claims, listw, nsim =999)
all_cc_mi  # Print results for all casualties

# Test for spatial autocorrelation specifically in cyclist casualty claims
cyc_cc_mi <- moran.mc(cma_da$n_cyclist_casualty_claims, listw, nsim =999)
cyc_cc_mi  # Print results for cyclist casualties

# Test for spatial autocorrelation specifically in pedestrian casualty claims
pd_cc_mi <- moran.mc(cma_da$n_pedestrian_casualty_claims, listw, nsim =999)
pd_cc_mi  # Print results for pedestrian casualties
pd_cc_mi -> moran_result
extract_moran_stats <- function(moran_result) {
  tibble(
    morans_i = round(moran_result$statistic["statistic"], 3),
    rank = paste0(moran_result$parameter,"/", length(moran_result$res)),
    pseudo_p_value = ifelse(moran_result$p.value < 0.001, 
                     "<0.001", 
                     round(moran_result$p.value, 3))
  )
}

# Create table of results
morans_table <- bind_rows(
  # Add each test result with a casualty type label
    mutate(extract_moran_stats(all_cc_mi), casualty_type = "All Injury Crashes"),
  mutate(extract_moran_stats(cyc_cc_mi), casualty_type = "Cyclist Involved Injury Crashes"),
  mutate(extract_moran_stats(pd_cc_mi), casualty_type = "Pedestrian Involved Injury Crashes"),
) %>%
  # Reorder columns
  select(casualty_type, morans_i, rank, pseudo_p_value) %>%
  # Rename columns for presentation
  rename(
    "Casualty Type" = casualty_type,
    "Moran's I" = morans_i,
    "Obs. Rank" = rank,
    "Psuedo p-value" = pseudo_p_value
  )

morans_table %>% 
  flextable() %>% 
  theme_booktabs()

```

Spatial autocorrelation analysis showed that all types of injury crashes were spatially clustered. Cyclist injury crashes had the highest spatial dependence (Moran's I = 0.386, pseduo p-value = 0.001), followed by pedestrian injury crashes (Moran's I = 0.308, pseduo p-value = 0.001) and all injury crashes (Moran's I = 0.245, pseduo p-value = 0.001). 


### BYM2 Models


### Statistical Methods

To model injury crashes across British Columbia, we employed a spatial Poisson regression model with a BYM2 (Besag-York-Mollié) component to account for spatial autocorrelation. The model was implemented using R-INLA (Integrated Nested Laplace Approximation) at the census dissemination area (DA) level (n = 6,225).

Let $Y_i$ represent the number of injury crashes in DA $i$. The model is specified as:

$Y_i \sim \text{Poisson}(\mu_i)$

$\log(\mu_i) = \eta_i$

where:

$\eta_i = \beta_0 + \beta_1\text{VanDIX}_i + \sum_{k=2}^{16}\beta_{2k}\text{Region}_{ki} + \sum_{k=2}^{16}\beta_{3k}(\text{VanDIX}_i \times \text{Region}_{ki}) + u_i$

The model includes 16 regional indicators ($\text{region}_{ki}$) with Vancouver-Fraser Valley serving as the reference category. The coefficient $\beta_{3k}$ represents the region-specific effect of the Vancouver Area Deprivation Index (VanDIX), capturing how the relationship between deprivation and injury crashes varies by region.

The spatial random effects component $u_i$ follows the BYM2 parameterization:

$u_i = \frac{1}{\sqrt{\tau_u}}(\sqrt{1-\phi}v_i + \sqrt{\phi}w_i)$

where $v_i$ is an unstructured (iid) random effect and $w_i$ is a structured spatial effect. The spatial neighborhood structure was defined using queen contiguity, where areas sharing at least one boundary point are considered neighbors.

For the hyperparameters, we specified penalized complexity (PC) priors:

- For the precision parameter $\tau_u$: PC prior with parameters (1, 0.001)
- For the mixing parameter $\phi$: PC prior with parameters (0.5, 0.5)

To handle disconnected components in the spatial structure, we employed sum-to-zero constraints for each region separately, using the adjust.for.con.comp = TRUE option in INLA. This approach assumes a common intercept across disconnected regions, with spatial random effects interpreted as area-specific deviations from the overall incidence within each region. The model was scaled with respect to each subgraph to ensure comparability of random effects across regions.

Model estimation was performed using the R-INLA package, with model fit assessed using the Deviance Information Criterion (DIC) and Watanabe-Akaike Information Criterion (WAIC).


```{r run models}

################################################################
################ All crashes
################################################################

nb2INLA("bc.adj", cma_nb)
cma_adj <- inla.read.graph(filename = "bc.adj")

prior <- list(prec = list(prior = "pc.prec", param = c(1, 0.001)),
              phi = list(prior = "pc", param = c(0.5, 0.5)))
# prior <- list( prec = list(prior = "pc.prec", param = c(0.5 / 0.31, 0.01)), 
#                phi = list( prior = "pc", param = c(0.5, 2 / 3)))

############## Poisson models


#### Unadjusted model - no random effects

f1_all <-  n_casualty_claims ~ vandix_z * region

m1_all <- inla(
  f1_all,
  data = cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

#### Unadjusted model - unstructured random effect

f2_all <-  n_casualty_claims ~ vandix_z * region + f(ui, model = 'iid')

m2_all <- inla(
  f2_all,
  data = cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

##### Unadjusted model - spatial random effect

f3_all <-  n_casualty_claims ~ vandix_z * region + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

#adjust.for.con.comp = TRUE, scale.model = TRUE:  assigns one intercept to each region in addition to using a sum-to-zero constraint for each connected region. By adding an intercept for each region, we infer that the baseline prevalence is different in the disconnected regions.

m3_all <- inla(
  f3_all,
  data =  cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)


############# ZIP models

#### Unadjusted model - no random effects

m1_all_zip <- inla(
  f1_all,
  data = cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

#### Unadjusted model - unstructured random effect

m2_all_zip <- inla(
  f2_all,
  data = cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

##### Unadjusted model - spatial random effect

#adjust.for.con.comp = TRUE, scale.model = TRUE:  assigns one intercept to each region in addition to using a sum-to-zero constraint for each connected region. By adding an intercept for each region, we infer that the baseline prevalence is different in the disconnected regions.


m3_all_zip <- inla(
  f3_all,
  data =  cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)


####### Model Comparisons

model_list_all <- list(m1_all, m1_all_zip, m2_all, m2_all_zip, m3_all, m3_all_zip)
model_names_all <- c(
  "poisson",
  "zi_poisson",
  "poisson_unstructured_re",
  "zi_poisson_unstructured_re",
  "poisson_unstructured_spatial_re",
  "zi_poisson_unstructured_spatial_re"
)

model_selection_all <- create_inla_comparison_table(model_list = model_list_all, model_names = model_names_all) %>%
  filter(parameter_type == "model_fit") %>%
  select(term, contains("mean")) %>%
  pivot_longer(cols = contains("mean")) %>%
  pivot_wider(id_cols = name,
              names_from = term,
              values_from = value)


model_selection_all %>%
  arrange(waic)

# Standard poisson distribution is best fitting model

#######  Adjusted model -

f4_all <-  n_casualty_claims ~ vandix_z * region + ln_roads_km_c + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

m4_all <- inla(
  f4_all,
  data =  cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)


#####  Adjusted model - spatial random effect

f5_all <-  n_casualty_claims ~ vandix_z * region + ln_roads_km_c +  roads_prop_highway_arterial_z +  bike_infra_cat + population_100_c + number_intersections_10_c  + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

m5_all <- inla(
  f5_all,
  data =  cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)




model_list_all <- list(m1_all, m2_all, m3_all, m4_all, m5_all)
model_names_all <- c(
  "unadjusted_no_random_effects",
  "unadjusted_stuctured_random_effect",
  "unadjusted_spatial_unstructured_re",
  "minimally_adjusted_spatial_unstructured_re",
  "adjusted_spatial_unstructured_re"
)
all_crashes_full_model_details <- create_inla_comparison_table(model_list = model_list_all, model_names = model_names_all)

######### Region Specific IRRs from Posterior Distribution of Vandix + Region Interaction

all_vandix_irr_unadjusted <- inla.posterior.sample(5000, m3_all)
all_vandix_irr_minimally_adjusted <- inla.posterior.sample(5000, m4_all)
all_vandix_irr_adjusted <- inla.posterior.sample(5000, m5_all)

all_vandix_irr_unadjusted <- vandix_irr(all_vandix_irr_unadjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))
all_vandix_irr_minimally_adjusted <- vandix_irr(all_vandix_irr_minimally_adjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))
all_vandix_irr_adjusted <- vandix_irr(all_vandix_irr_adjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))


vandix_irr_all_crashes_models <- left_join(all_vandix_irr_unadjusted,
                                           all_vandix_irr_minimally_adjusted,
                                           by = "region") %>%
  left_join(all_vandix_irr_adjusted, by = "region") %>%
  mutate(Term = "VanDIX (SD)") %>%
  select(Term, region, contains("IRR (95% CI)")) %>%
  flextable() %>%
  add_header_row(
    values = c("", "Incidence Rate Ratio (95% Credible Interval)"),
    colwidths = c(2, 3)
  ) %>%
  set_header_labels(values = c(
    "Term",
    "Region",
    "Unadjusted",
    "Minimally Adjusted",
    "Adjusted"
  )) %>%
  footnote(
    i = c(2),
    j = c(3, 4, 5),
    value = as_paragraph(
      c(
        "Poisson model fit with idd and spatial random effect at dissemination area level",
        "Poisson model fit with idd and spatial random effect at dissemination area level + adjusted for (i) total length of road lanes",
        "Poisson model fit with idd and spatial random effect at dissemination area level + adjusted for (i) total length of road lanes; (ii) proportion of lanes classified as highway or arterial; (iii) number of intersections; (iv) presence of bicycling infrastructure; (v) total population"
      )
    ),
    ref_symbols = c("a", "b", "c"),
    part = "header",
    inline = FALSE
  ) %>%
  merge_v(j = ~ Term) %>%
  theme_booktabs() %>%
  set_table_properties(layout = "autofit") %>%
  valign(valign = "bottom", part = "header") %>%
  set_caption(
    "Table 3. Incidence Rate Ratios (IRR) with 95% Credible Intervals for all motor vehicle crashes in relation to a standard deviation increase in deprivation, measured by the Vancouver Area Deprivation Index (VanDIX). Results are shown for different statistical models including unadjusted, minimally adjusted and adjusted."
  )


################################################################
################ Cyclist Crashes
################################################################

# prior <- list(prec = list(prior = "pc.prec", param = c(1, 0.001)),
#               phi = list(prior = "pc", param = c(0.5, 0.5)))

############## Poisson models

#### Unadjusted model - no random effects

f1_cyclist <-  n_cyclist_casualty_claims ~ vandix_z * region

m1_cyclist <- inla(
  f1_cyclist,
  data = cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

#### Unadjusted model - unstructured random effect

f2_cyclist <-  n_cyclist_casualty_claims ~ vandix_z * region + f(ui, model = 'iid')

m2_cyclist <- inla(
  f2_cyclist,
  data = cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

##### Unadjusted model - spatial random effect

f3_cyclist <-  n_cyclist_casualty_claims ~ vandix_z * region + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

#adjust.for.con.comp = TRUE, scale.model = TRUE:  assigns one intercept to each region in addition to using a sum-to-zero constraint for each connected region. By adding an intercept for each region, we infer that the baseline prevalence is different in the disconnected regions.

m3_cyclist <- inla(
  f3_cyclist,
  data =  cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

############## ZIP models

#### Unadjusted model - no random effects

m1_cyclist_zip <- inla(
  f1_cyclist,
  data = cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)



#### Unadjusted model - unstructured random effect

m2_cyclist_zip <- inla(
  f2_cyclist,
  data = cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

##### Unadjusted model - spatial random effect

#adjust.for.con.comp = TRUE, scale.model = TRUE:  assigns one intercept to each region in addition to using a sum-to-zero constraint for each connected region. By adding an intercept for each region, we infer that the baseline prevalence is different in the disconnected regions.


m3_cyclist_zip <- inla(
  f3_cyclist,
  data =  cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

####### Model Comparisons

model_list_cyclist <- list(m1_cyclist,
                           m1_cyclist_zip,
                           m2_cyclist,
                           m2_cyclist_zip,
                           m3_cyclist,
                           m3_cyclist_zip)
model_names_cyclist <- c(
  "poisson",
  "zi_poisson",
  "poisson_unstructured_re",
  "zi_poisson_unstructured_re",
  "poisson_unstructured_spatial_re",
  "zi_poisson_unstructured_spatial_re"
)


model_selection_cyclist <- create_inla_comparison_table(model_list = model_list_cyclist, model_names = model_names_cyclist) %>%
  filter(parameter_type == "model_fit") %>%
  select(term, contains("mean")) %>%
  pivot_longer(cols = contains("mean")) %>%
  pivot_wider(id_cols = name,
              names_from = term,
              values_from = value)

model_selection_cyclist %>% 
  arrange(waic)

#Best fitting model is ZIP BYM2

#######  Adjusted model -

f4_cyclist <-  n_cyclist_casualty_claims ~ vandix_z * region + ln_roads_km_c + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

m4_cyclist_zip <- inla(
  f4_cyclist,
  data =  cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)


#####  Adjusted model - spatial random effect

f5_cyclist <-  n_cyclist_casualty_claims ~ vandix_z * region + ln_roads_km_c +  roads_prop_highway_arterial_z +  bike_infra_cat + population_100_c + number_intersections_10_c  + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

m5_cyclist_zip <- inla(
  f5_cyclist,
  data =  cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)



model_list_cyclist <- list(m1_cyclist_zip,
                           m2_cyclist_zip,
                           m3_cyclist_zip,
                           m4_cyclist_zip,
                           m5_cyclist_zip)
model_names_cyclist <- c(
  "unadjusted_no_random_effects",
  "unadjusted_stuctured_random_effect",
  "unadjusted_spatial_unstructured_re",
  "minimally_adjusted_spatial_unstructured_re",
  "adjusted_spatial_unstructured_re"
)
cyclist_crashes_full_model_details <- create_inla_comparison_table(model_list = model_list_cyclist, model_names = model_names_cyclist)


######### Region Specific IRRs from Posterior Distribution of Vandix + Region Interaction
cyclist_vandix_irr_unadjusted <- inla.posterior.sample(5000, m3_cyclist_zip)
cyclist_vandix_irr_minimally_adjusted <- inla.posterior.sample(5000, m4_cyclist_zip)
cyclist_vandix_irr_adjusted <- inla.posterior.sample(5000, m5_cyclist_zip)

cyclist_vandix_irr_unadjusted <- vandix_irr(cyclist_vandix_irr_unadjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))
cyclist_vandix_irr_minimally_adjusted <- vandix_irr(cyclist_vandix_irr_minimally_adjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))
cyclist_vandix_irr_adjusted <- vandix_irr(cyclist_vandix_irr_adjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))


vandix_irr_cyclist_crashes_models <- left_join(cyclist_vandix_irr_unadjusted,
                                               cyclist_vandix_irr_minimally_adjusted,
                                               by = "region") %>%
  left_join(cyclist_vandix_irr_adjusted, by = "region") %>%
  mutate(Term = "VanDIX (SD)") %>%
  select(Term, region, contains("IRR (95% CI)")) %>%
  flextable() %>%
  add_header_row(
    values = c("", "Incidence Rate Ratio (95% Credible Interval)"),
    colwidths = c(2, 3)
  ) %>%
  set_header_labels(values = c(
    "Term",
    "Region",
    "Unadjusted",
    "Minimally Adjusted",
    "Adjusted"
  )) %>%
  footnote(
    i = c(2),
    j = c(3, 4, 5),
    value = as_paragraph(
      c(
        "Zero-Inflated Poisson model fit with idd and spatial random effect at dissemination area level",
        "Zero-Inflated Poisson model fit with idd and spatial random effect at dissemination area level + adjusted for (i) total length of road lanes",
        "Zero-Inflated Poisson model fit with idd and spatial random effect at dissemination area level + adjusted for (i) total length of road lanes; (ii) proportion of lanes classified as highway or arterial; (iii) number of intersections; (iv) presence of bicycling infrastructure; (v) total population"
      )
    ),
    ref_symbols = c("a", "b", "c"),
    part = "header",
    inline = FALSE
  ) %>%
  merge_v(j = ~ Term) %>%
  theme_booktabs() %>%
  set_table_properties(layout = "autofit") %>%
  valign(valign = "bottom", part = "header") %>%
  set_caption(
    "Table 4. Incidence Rate Ratios (IRR) with 95% Credible Intervals for cyclist- motor vehicle crashes in relation to a standard deviation increase in deprivation, measured by the Vancouver Area Deprivation Index (VanDIX). Results are shown for different statistical models including unadjusted, minimally adjusted and adjusted."
  )


################################################################
################ Pedestrian Crashes
################################################################

# prior <- list(prec = list(prior = "pc.prec", param = c(1, 0.001)),
#               phi = list(prior = "pc", param = c(0.5, 0.5)))


############## Poisson models


#### Unadjusted model - no random effects

f1_pedestrian <-  n_pedestrian_casualty_claims ~ vandix_z * region

m1_pedestrian <- inla(
  f1_pedestrian,
  data = cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

#### Unadjusted model - unstructured random effect

f2_pedestrian <-  n_pedestrian_casualty_claims ~ vandix_z * region + f(ui, model = 'iid')

m2_pedestrian <- inla(
  f2_pedestrian,
  data = cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

##### Unadjusted model - spatial random effect

f3_pedestrian <-  n_pedestrian_casualty_claims ~ vandix_z * region + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

#adjust.for.con.comp = TRUE, scale.model = TRUE:  assigns one intercept to each region in addition to using a sum-to-zero constraint for each connected region. By adding an intercept for each region, we infer that the baseline prevalence is different in the disconnected regions.

m3_pedestrian <- inla(
  f3_pedestrian,
  data =  cma_sp@data,
  family = "poisson",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

############## ZIP models

#### Unadjusted model - no random effects

m1_pedestrian_zip <- inla(
  f1_pedestrian,
  data = cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)



#### Unadjusted model - unstructured random effect

m2_pedestrian_zip <- inla(
  f2_pedestrian,
  data = cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)

##### Unadjusted model - spatial random effect

#adjust.for.con.comp = TRUE, scale.model = TRUE:  assigns one intercept to each region in addition to using a sum-to-zero constraint for each connected region. By adding an intercept for each region, we infer that the baseline prevalence is different in the disconnected regions.


m3_pedestrian_zip <- inla(
  f3_pedestrian,
  data =  cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)



####### Model Comparisons


model_list_pedestrian <- list(
  m1_pedestrian,
  m1_pedestrian_zip,
  m2_pedestrian,
  m2_pedestrian_zip,
  m3_pedestrian,
  m3_pedestrian_zip
)
model_names_pedestrian <- c(
  "poisson",
  "zi_poisson",
  "poisson_unstructured_re",
  "zi_poisson_unstructured_re",
  "poisson_unstructured_spatial_re",
  "zi_poisson_unstructured_spatial_re"
)


model_selection_pedestrian <- create_inla_comparison_table(model_list = model_list_pedestrian, model_names = model_names_pedestrian) %>%
  filter(parameter_type == "model_fit") %>%
  select(term, contains("mean")) %>%
  pivot_longer(cols = contains("mean")) %>%
  pivot_wider(id_cols = name,
              names_from = term,
              values_from = value)


model_selection_pedestrian %>%
  arrange(waic)


#Best fitting model is ZIP BYM2

#######  Adjusted model -

f4_pedestrian <-  n_pedestrian_casualty_claims ~ vandix_z * region + ln_roads_km_c + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

m4_pedestrian_zip <- inla(
  f4_pedestrian,
  data =  cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)


#####  Adjusted model - spatial random effect

f5_pedestrian <-  n_pedestrian_casualty_claims ~ vandix_z * region + ln_roads_km_c +  roads_prop_highway_arterial_z +  bike_infra_cat + population_100_c + number_intersections_10_c  + f(
  ui,
  model = 'bym2',
  graph = cma_adj,
  hyper = prior,
  adjust.for.con.comp = TRUE,
  constr = TRUE,
  scale.model = TRUE
)

m5_pedestrian_zip <- inla(
  f5_pedestrian,
  data =  cma_sp@data,
  family = "zeroinflatedpoisson1",
  control.compute = list(dic = TRUE, waic = TRUE, config = TRUE),
  control.predictor = list(compute = TRUE),
  verbose = FALSE
)




model_list_pedestrian <- list(
  m1_pedestrian_zip,
  m2_pedestrian_zip,
  m3_pedestrian_zip,
  m4_pedestrian_zip,
  m5_pedestrian_zip
)
model_names_pedestrian <- c(
  "unadjusted_no_random_effects",
  "unadjusted_stuctured_random_effect",
  "unadjusted_spatial_unstructured_re",
  "minimally_adjusted_spatial_unstructured_re",
  "adjusted_spatial_unstructured_re"
)
pedestrian_crashes_full_model_details <- create_inla_comparison_table(model_list = model_list_pedestrian, model_names = model_names_pedestrian)


######### Region Specific IRRs from Posterior Distribution of Vandix + Region Interaction
pedestrian_vandix_irr_unadjusted <- inla.posterior.sample(5000, m3_pedestrian_zip)
pedestrian_vandix_irr_minimally_adjusted <- inla.posterior.sample(5000, m4_pedestrian_zip)
pedestrian_vandix_irr_adjusted <- inla.posterior.sample(5000, m5_pedestrian_zip)

pedestrian_vandix_irr_unadjusted <- vandix_irr(pedestrian_vandix_irr_unadjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))
pedestrian_vandix_irr_minimally_adjusted <- vandix_irr(pedestrian_vandix_irr_minimally_adjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))
pedestrian_vandix_irr_adjusted <- vandix_irr(pedestrian_vandix_irr_adjusted) %>%
  mutate(`IRR (95% CI)` = paste0(
    signif(irr_mean, 3),
    " (",
    signif(irr_low, 3),
    ", ",
    signif(irr_high, 3),
    ")"
  ))


vandix_irr_pedestrian_crashes_models <- left_join(pedestrian_vandix_irr_unadjusted,
                                                  pedestrian_vandix_irr_minimally_adjusted,
                                                  by = "region") %>%
  left_join(pedestrian_vandix_irr_adjusted, by = "region") %>%
  mutate(Term = "VanDIX (SD)") %>%
  select(Term, region, contains("IRR (95% CI)")) %>%
  flextable() %>%
  add_header_row(
    values = c("", "Incidence Rate Ratio (95% Credible Interval)"),
    colwidths = c(2, 3)
  ) %>%
  set_header_labels(values = c(
    "Term",
    "Region",
    "Unadjusted",
    "Minimally Adjusted",
    "Adjusted"
  )) %>%
  footnote(
    i = c(2),
    j = c(3, 4, 5),
    value = as_paragraph(
      c(
        "Zero-Inflated Poisson model fit with idd and spatial random effect at dissemination area level",
        "Zero-Inflated Poisson model fit with idd and spatial random effect at dissemination area level + adjusted for (i) total length of road lanes",
        "Zero-Inflated Poisson model fit with idd and spatial random effect at dissemination area level + adjusted for (i) total length of road lanes; (ii) proportion of lanes classified as highway or arterial; (iii) number of intersections; (iv) presence of bicycling infrastructure; (v) total population"
      )
    ),
    ref_symbols = c("a", "b", "c"),
    part = "header",
    inline = FALSE
  ) %>%
  merge_v(j = ~ Term) %>%
  theme_booktabs() %>%
  set_table_properties(layout = "autofit") %>%
  valign(valign = "bottom", part = "header") %>%
  set_caption(
    "Table 5. Incidence Rate Ratios (IRR) with 95% Credible Intervals for pedestrian-motor vehicle crashes in relation to a standard deviation increase in deprivation, measured by the Vancouver Area Deprivation Index (VanDIX). Results are shown for different statistical models including unadjusted, minimally adjusted and adjusted."
  )

n <- nrow(cma_da)

cma_da$re_all_adjusted <-  m5_all$summary.random$ui[1:nrow(cma_da), "mean"]
cma_da$re_cyclist_adjusted <-  m5_cyclist_zip$summary.random$ui[1:nrow(cma_da), "mean"]
cma_da$re_pedestrian_adjusted <-  m5_pedestrian_zip$summary.random$ui[1:nrow(cma_da), "mean"]



### LISA for Random Effects



cma_listw <- nb2listw(include.self(cma_nb),style = "B")

# Cluster analysis - unexplained variation in all injuries 

re_all_adjusted_gstar <- localG_perm(
  cma_da$re_all_adjusted,
  cma_listw,
  nsim = 100000,
  zero.policy = attr(listw, "zero.policy"),
  spChk = NULL,
  alternative = "two.sided",
  iseed = NULL,
  fix_i_in_Gstar_permutations = TRUE,
  no_repeat_in_row = FALSE
)

alpha = 0.001

re_all_adjusted_gstar_internals <- as_tibble(attr(re_all_adjusted_gstar,"internals")) %>% 
  mutate(cluster = case_when(`Pr(z != E(Gi)) Sim` <alpha &  StdDev.Gi > 0 ~ "High",
                             `Pr(z != E(Gi)) Sim` <alpha & StdDev.Gi < 0 ~ "Low",
                             TRUE ~ "Not significant"
                             ))
cma_da$re_all_adjusted_gstar_cluster <- as.factor(re_all_adjusted_gstar_internals$cluster)



# Cluster analysis - unexplained variation in cyclist injuries 

re_cyclist_adjusted_gstar <- localG_perm(
  cma_da$re_cyclist_adjusted,
  cma_listw,
  nsim = 100000,
  zero.policy = attr(listw, "zero.policy"),
  spChk = NULL,
  alternative = "two.sided",
  iseed = NULL,
  fix_i_in_Gstar_permutations = TRUE,
  no_repeat_in_row = FALSE
)

re_cyclist_adjusted_gstar_internals <- as_tibble(attr(re_cyclist_adjusted_gstar,"internals")) %>% 
  mutate(cluster = case_when(`Pr(z != E(Gi)) Sim` <alpha &  StdDev.Gi > 0 ~ "High",
                             `Pr(z != E(Gi)) Sim` <alpha & StdDev.Gi < 0 ~ "Low",
                             TRUE ~ "Not significant"
                             ))
cma_da$re_cyclist_adjusted_gstar_cluster <- as.factor(re_cyclist_adjusted_gstar_internals$cluster)


# Cluster analysis - unexplained variation in pedestrian injuries 

re_pedestrian_adjusted_gstar <- localG_perm(
  cma_da$re_pedestrian_adjusted,
  cma_listw,
  nsim = 100000,
  zero.policy = attr(listw, "zero.policy"),
  spChk = NULL,
  alternative = "two.sided",
  iseed = NULL,
  fix_i_in_Gstar_permutations = TRUE,
  no_repeat_in_row = FALSE
)

re_pedestrian_adjusted_gstar_internals <- as_tibble(attr(re_pedestrian_adjusted_gstar,"internals")) %>% 
  mutate(cluster = case_when(`Pr(z != E(Gi)) Sim` <alpha &  StdDev.Gi > 0 ~ "High",
                             `Pr(z != E(Gi)) Sim` <alpha & StdDev.Gi < 0 ~ "Low",
                             TRUE ~ "Not significant"
                             ))
cma_da$re_pedestrian_adjusted_gstar_cluster <- as.factor(re_pedestrian_adjusted_gstar_internals$cluster)

### Moran's I on residuals 

all_resid_mi <- moran.mc(residuals(m5_all, "pearson"),
         listw = listw,
         nsim = 999)
all_resid_mi
cyclist_resid_mi <- moran.mc(residuals(m5_cyclist_zip, "pearson"),
         listw = listw,
         nsim = 999)
cyclist_resid_mi
pedestrian_resid_mi <-moran.mc(residuals(m5_pedestrian_zip, "pearson"),
         listw = listw,
         nsim = 999)
pedestrian_resid_mi

# Create table of results
morans_table <- bind_rows(
  # Add each test result with a casualty type label
    mutate(extract_moran_stats(all_resid_mi), casualty_type = "All Injury Crashes"),
  mutate(extract_moran_stats(cyclist_resid_mi), casualty_type = "Cyclist Involved Injury Crashes"),
  mutate(extract_moran_stats(pedestrian_resid_mi), casualty_type = "Pedestrian Involved Injury Crashes"),
) %>%
  # Reorder columns
  select(casualty_type, morans_i, rank, pseudo_p_value) %>%
  # Rename columns for presentation
  rename(
    "Casualty Type" = casualty_type,
    "Moran's I" = morans_i,
    "Obs. Rank" = rank,
    "Psuedo p-value" = pseudo_p_value
  )

morans_table %>% 
  flextable() %>% 
  theme_booktabs()

```

Spatial autocorrelation analysis show no evidence of significant spatial autocorrelation in the residuals. Specifically, for all injury crashes, cyclist injury crashes, and pedestrian injury crashes, the Moran’s I statistics were –0.027 (p = 0.999), –0.035 (p = 0.999), and –0.048 (p = 0.999), respectively. 

# Study Area

## Figure 1

```{r study area figure, fig.width= 9.448819, fig.height=9.448819,warning=FALSE,message=FALSE,fig.cap="Regional Grouping of Census Metropolitan and Agglomeration Areas. Labelled Points Represent Census Metroplitan Area and Census Agglomeration Centroids"}

cma_centroids <- cma_da %>% 
  group_by(cma_name) %>% 
  summarise(shape_area = sum(landarea)) %>% 
  st_cast() %>% 
  st_centroid() 


cma_boundary <- cma_da %>% 
  group_by(cma_name) %>% 
  summarise(shape_area = sum(landarea)) %>% 
  st_cast()

# cma_da <- cma_da %>% 
#  mutate(region_name = factor(region_name, levels = regions$region_name))


nb_colours <- 16
colour_pal <- colorRampPalette(carto_pal(12, "Antique"))(nb_colours)


label_positions <- data.frame(
  cma_name = cma_centroids$cma_name,
  x = st_coordinates(cma_centroids)[,1],
  y = st_coordinates(cma_centroids)[,2],
  label_x = st_coordinates(cma_centroids)[,1] + c(
    50000,    # Abbotsford - Mission 
    -70000,   # Campbell River (left)
    80000,    # Chilliwack (right)
    -100000,   # Courtenay (left)
    -50000,    # Cranbrook (left)
    -100000,    # Dawson Creek (right)
    -70000,   # Duncan (left)
    -20000,    # Fort St. John 
    55000,    # Kamloops (right)
    -85000,    # Kelowna (left)
    -60000,   # Ladysmith (left)
    -120000,   # Nanaimo (left)
    30000,    # Nelson (right)
    35000,   # Parksville (left)
    95000,    # Penticton (right)
    -100000,   # Port Alberni (left)
    40000,   # Powell River (right
    -100000,        # Prince George (left)
    -80000,   # Prince Rupert (left)
    -125000,        # Quesnel (left)
    80000,    # Salmon Arm (right)
    25000,    # Squamish (right)
    0,   # Terrace (left)
    -35000,    # Trail (left)
    30000,   # Vancouver (right )
    60000,    # Vernon (right)
    80000,   # Victoria (right)
    50000        # Williams Lake (right)
  ),
  label_y = st_coordinates(cma_centroids)[,2] + c(
    50000,   # Abbotsford - Mission (up)
    40000,     # Campbell River (up)
    11000,    # Chilliwack 
    20000,     # Courtenay ( up)
    60000,        # Cranbrook (down)
    0,    # Dawson Creek ()
    -50000,   # Duncan (down )
    39000,    # Fort St. John (up)
    55000,    # Kamloops (up)
    10000,        # Kelowna (up)
    -30000,   # Ladysmith (down)
    -12000,     # Nanaimo 
    -35000,        # Nelson (down)
    30000,     # Parksville (up)
    35000,   # Penticton (up)
    0,        # Port Alberni (level as shown)
    50000,     # Powell River (slight up)
    60000,    # Prince George (up)
    80000,        # Prince Rupert (level as shown)
    -30000,   # Quesnel (down to match North Central spacing)
    15000,    # Salmon Arm (up to match interior spacing)
    30000,    # Squamish (up to match shown position)
    72500,        # Terrace (up)
    25000,   # Trail (up)
    -40000,   # Vancouver (down)
    15000,    # Vernon (up to match Okanagan spacing)
    0,   # Victoria ()
    -60000    # Williams Lake (down to match North Central spacing)
  )
)

# Add to your existing ggplot
study_area <- ggplot() +
  # Your existing map layers here
  geom_sf(data = bc_boundary,
          fill = "grey99",
          colour = "grey70")  +
  geom_sf(data = cma_da, aes(fill = region, colour = region)) + 
  # Add leader lines
  geom_segment(
    data = label_positions,
    aes(x = x, y = y, xend = label_x, yend = label_y),
    color = "black",
    alpha = 0.25,
    linewidth = 0.3
  ) +
  geom_sf(data = cma_centroids,size = 0.15) +
  # Add labels
  geom_label(
    data = label_positions,
    aes(x = label_x, y = label_y, label = cma_name),
    size = 2
    # hjust = ifelse(label_positions$label_x > label_positions$x, 0, 1) # Align text based on position relative to point
  ) +
  scale_fill_manual(name = "Region", 
                   values = colour_pal) + 
  scale_colour_manual(name = "Region", 
                     values = colour_pal) +
  # scale_fill_carto_d(name = "Region", palette = "Antique") +
  # scale_colour_carto_d(name = "Region", palette = "Antique") +
  theme_void(
    base_size = 10
  ) +
  theme(
    text = element_text(family = "Arial"),
    legend.title = element_text(size =12),
    legend.position = "inside",
    legend.position.inside = c(0,0.10),
    legend.justification = c("left", "bottom"),
    legend.box.just = "right") 


ggsave(
  device = "svg",
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/Figure_1.jpg",
  plot = study_area,
  units = "mm",
  height = 140*1.1,
  width = 190*1.1,
  dpi = 600
)



ggsave(
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/Figure_1.jpg",
  plot = study_area,
  units = "mm",
  height = 140*1.1,
  width = 190*1.1,
  dpi = 600
)


study_area
```


# Results

## Regional Characteristics

### Table 1 - Population, Built Environment Characteristics

```{r table 1}
cma_da_tibble <- cma_da %>%
  st_drop_geometry()

regions_data <- cma_da_tibble %>% 
  group_by(region) %>% 
  summarise(
    # n = n(),
    # median_pop_density = median(population/landarea),
    # iqr_pop_density = IQR(population/landarea),
    
    total_population = sum(population),
    # total_land_area = sum(landarea),,
    total_lane_length_km = sum(total_lane_length_km),
    # median_neighbourhood_size = median(landarea),
    # iqr_neighbourhood_size = IQR(landarea)
  )
    
  
# Use scale() to standardize the variables
regions_scaled <- scale(regions_data[, c("total_population","total_lane_length_km")])

# Perform K-means clustering
# Try different numbers of clusters
set.seed(123)

# Function to calculate total within-cluster sum of squares
wss <- function(k) {
  kmeans(regions_scaled, k, nstart = 10)$tot.withinss
}

# Determine optimal number of clusters using elbow method
k_values <- 2:15
wss_values <- sapply(k_values, wss)

# Plot elbow curve
plot(k_values, wss_values, type = "b", 
     xlab = "Number of Clusters", 
     ylab = "Total Within-Cluster Sum of Squares",
     main = "Elbow Method for Optimal Clusters")

# Perform clustering with chosen number of clusters (based on elbow plot)
set.seed(123)
cluster <- kmeans(regions_scaled, centers = 5)

augment(cluster,regions_data) %>% 
  arrange(.cluster)

# Add cluster assignments to the original dataframe
regions_data$Cluster <- cluster$cluster

# Visualize the clusters
# ggplot(regions_data, aes(x = log(total_lane_length_km) , y = log(total_population), color = factor(Cluster), label = region)) +
#   geom_point(size = 4) +
#   ggrepel::geom_text_repel(point.padding = 0.5,size = 4,max.overlaps = 10000) +
#   labs(title = "Regional Clusters",
#        color = "Cluster") +
#   theme_minimal()


region <- cma_da_tibble %>% 
  left_join(regions_data,by = "region") %>% 
  mutate(name = case_when(Cluster==1~"Mid-Sized",
                          Cluster==2~"Small",
                          Cluster==3~"Northeast",
                          Cluster==4~"Mid-Sized",
                          Cluster==5~"Vancouver")) %>% 
    group_by(region,name) %>% 
  summarise(population = sum(population),
            lane_kilometres = sum(total_lane_length_km.x),
            landarea = sum(landarea),
            n_casualty_claims = sum(n_casualty_claims),
            n_cyclist_casualty_claims = sum(n_cyclist_casualty_claims),
                        n_pedestrian_casualty_claims = sum(n_pedestrian_casualty_claims)

            ) %>% 
  ungroup()

# region %>% 
#   group_by(name) %>% 
#   summarise(total_population = sum(population),
#             min_population = min(population),
#             max_population = max(population),
#             
#             total_lane_kilometres = sum(lane_kilometres),
#             min_lane_kilometres = min(lane_kilometres),
#             max_lane_kilometres = max(lane_kilometres),
#             
#             total_landarea = sum(landarea),
#             min_landarea = min(landarea),
#             max_landarea = max(landarea),
#             
#             total_n_casualty_claims = sum(n_casualty_claims),
#             min_n_casualty_claims = min(n_casualty_claims),
#             max_n_casualty_claims = max(n_casualty_claims),
#             
#            total_n_cyclist_casualty_claims = sum(n_cyclist_casualty_claims),
#             min_n_cyclist_casualty_claims = min(n_cyclist_casualty_claims),
#             max_n_cyclist_casualty_claims = max(n_cyclist_casualty_claims),
#             
#                        
#            total_n_pedestrian_casualty_claims = sum(n_pedestrian_casualty_claims),
#             min_n_pedestrian_casualty_claims = min(n_pedestrian_casualty_claims),
#             max_n_pedestrian_casualty_claims = max(n_pedestrian_casualty_claims),
#            
#   ) %>% 
#   mutate(total_population_p = total_population/sum(total_population)*100,
#          total_lane_kilometres_p = total_lane_kilometres/sum(total_lane_kilometres)*100,
#                   total_landarea_p = total_landarea/sum(total_landarea)*100,
#          total_n_casualty_claims_p = total_n_casualty_claims/sum(total_n_casualty_claims)*100,
#          total_n_cyclist_casualty_claims_p = total_n_cyclist_casualty_claims/sum(total_n_cyclist_casualty_claims)*100,
#          total_n_pedestrian_casualty_claims_p = total_n_pedestrian_casualty_claims/sum(total_n_cyclist_casualty_claims)*100
# 
#          
#   ) 





total_row <- cma_da_tibble %>%
 summarise(
   Region = "Total Study Area",
   `Number of DAs` = format(n(), big.mark = ","),
   `Total Land Area (1000 Km2)` = round(sum(landarea/1000),1),
   
      
      `Mean Land Area by DA (SD)` = paste0(
     round(mean(landarea, na.rm = TRUE), 1), 
     " (", round(sd(landarea , na.rm = TRUE), 1), ")"
   ),
   
   
   `Total Population (1000s)` = format(round(sum(population, na.rm = TRUE)/1000, 1), big.mark = ","),

      `Mean Population Density by DA (SD)` = paste0(
     round(mean(population/landarea, na.rm = TRUE), 1), 
     " (", round(sd(population/landarea , na.rm = TRUE), 1), ")"
   ),
   
   
   `Mean Population by DA (SD)` = paste0(
     round(mean(population, na.rm = TRUE), 1), 
     " (", round(sd(population, na.rm = TRUE), 1), ")"
   ),
   
   `Total Lane Kilometres (1000s)` = format(round(sum(total_lane_length_km, na.rm = TRUE)/1000, 1), big.mark = ","),

      `Mean Lane Kilometres by DA (SD)` = paste0(
     round(mean(total_lane_length_km, na.rm = TRUE), 1),
     " (", round(sd(total_lane_length_km, na.rm = TRUE), 1), ")"
   ),
   
   
   `Mean  % Lane Kilometers Major by DA (SD)` = paste0(
     round(100*mean(roads_prop_highway_arterial, na.rm = TRUE), 1), 
     " (", round(100*sd(roads_prop_highway_arterial, na.rm = TRUE), 1), ")"
   ),
   
   `Mean Total Intersections by DA (SD)` = paste0(
     round(mean(number_intersections, na.rm = TRUE), 1),
     " (", round(sd(number_intersections, na.rm = TRUE), 1), ")"
   ),
   
   `Bike Infrastructure Presence` = paste0(round(100*sum(any_bike_infra=="Yes")/n(), 1),"%"),
   
    `Mean VanDIX (SD)` = paste0(
     round(mean(vandix_z, na.rm = TRUE), 1),
     " (", round(sd(vandix_z, na.rm = TRUE), 1), ")"
   )
 )



# Main table
table1 <- cma_da_tibble %>%  
 rename(Region = region) %>% 
 group_by(Region) %>%
 summarise(
   `Number of DAs` = format(n(), big.mark = ","),
      `Total Land Area (1000 Km2)` = round(sum(landarea/1000),1),
   
         
      `Mean Land Area by DA (SD)` = paste0(
     round(mean(landarea, na.rm = TRUE), 1), 
     " (", round(sd(landarea , na.rm = TRUE), 1), ")"
   ),

   `Total Population (1000s)` = format(round(sum(population, na.rm = TRUE)/1000, 1), big.mark = ","),
   `Mean Population by DA (SD)` = paste0(
     round(mean(population, na.rm = TRUE), 1), 
     " (", round(sd(population, na.rm = TRUE), 1), ")"
   ),
   
         `Mean Population Density by DA (SD)` = paste0(
     round(mean(population/landarea, na.rm = TRUE), 1), 
     " (", round(sd(population/landarea , na.rm = TRUE), 1), ")"
   ),
   
   
   `Total Lane Kilometres (1000s)` = format(round(sum(total_lane_length_km, na.rm = TRUE)/1000, 1), big.mark = ","),
   
   `Mean Lane Kilometres by DA (SD)` = paste0(
     round(mean(total_lane_length_km, na.rm = TRUE), 1),
     " (", round(sd(total_lane_length_km, na.rm = TRUE), 1), ")"
   ),
   
   `Mean  % Lane Kilometers Major by DA (SD)` = paste0(
     round(100*mean(roads_prop_highway_arterial, na.rm = TRUE), 1), 
     " (", round(100*sd(roads_prop_highway_arterial, na.rm = TRUE), 1), ")"
   ),
   
   `Mean Total Intersections by DA (SD)` = paste0(
     round(mean(number_intersections, na.rm = TRUE), 1),
     " (", round(sd(number_intersections, na.rm = TRUE), 1), ")"
   ),
   
   `Bike Infrastructure Presence` = paste0(round(100*sum(any_bike_infra=="Yes")/n(), 1),"%"),
   
     `Mean VanDIX (SD)` = paste0(
     round(mean(vandix_z, na.rm = TRUE), 1),
     " (", round(sd(vandix_z, na.rm = TRUE), 1), ")"
   )
 ) %>%
 bind_rows(total_row) %>%
 arrange(match(Region, c("Total Study Area", unique(cma_da_tibble$region)))) %>%
 flextable() %>% 
 add_header_row(
   values = c("", "Population Characteristics", "Built Environment and Road Network Characteristics", "Area Deprivation"),
   colwidth = c(2, 5, 5, 1)
 ) %>%
 add_footer_lines(values = "DA = Dissemination Area; SD = Standard Deviation") %>%
 set_caption("Table 1. Regional summary statistics for population characteristics, socioeconomic indicators and built environment characteristics by region. Values are presented as totals, means with standard deviations (SD), or prevalences where appropriate.") %>%
 set_table_properties(layout = "autofit", width = 1) %>%
 fontsize(size = 8, part = "all") %>%
 padding(padding = 2, part = "all") %>%
 theme_booktabs() %>%
 fit_to_width(max_width = 15)


table1
save_as_image(table1 %>% autofit(), "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/regional_injury_be_descriptive.svg", expand = 1, res = 150)


```

### Table 2 - Injury Crashes 

```{r table 2}

total_row <- cma_da_tibble %>%
 summarise(
   Region = "Total Study Area",
      `Total Injury Crashes` = format(sum(n_casualty_claims), big.mark = ","),

    `Median Injury Crashes (IQR)` = paste0(
      signif(median(n_casualty_claims), 3),
      " (", signif(IQR(n_casualty_claims), 3), ")"
    ),
    `Injury Crashes == 0` = paste0(
      signif(100 * sum(n_casualty_claims == 0) / n(), 3), "%"
    ),

    `Total Cycling Injury Crashes` = format(sum(n_cyclist_casualty_claims), big.mark = ","),
    `Cycling Injury Crashes == 0` = paste0(
      signif(100 * sum(n_cyclist_casualty_claims == 0) / n(), 3), "%"
    ),

    `Median Cycling Injury Crashes (IQR)` = paste0(
      signif(median(n_cyclist_casualty_claims), 3),
      " (", signif(IQR(n_cyclist_casualty_claims), 3), ")"
    ),

    `Total Pedestrian Injury Crashes` = format(sum(n_pedestrian_casualty_claims), big.mark = ","),

    `Median Pedestrian Injury Crashes (IQR)` = paste0(
      signif(median(n_pedestrian_casualty_claims), 3),
      " (", signif(IQR(n_pedestrian_casualty_claims), 3), ")"
    ),

    `Pedestrian Injury Crashes == 0` = paste0(
      signif(100 * sum(n_pedestrian_casualty_claims == 0) / n(), 3), "%"
    )

   )




# Main table
table2 <- cma_da_tibble %>%  
 rename(Region = region) %>% 
 group_by(Region) %>%
 summarise(
      `Total Injury Crashes` = format(sum(n_casualty_claims), big.mark = ","),

    `Median Injury Crashes (IQR)` = paste0(
      signif(median(n_casualty_claims), 3),
      " (", signif(IQR(n_casualty_claims), 3), ")"
    ),
    `Injury Crashes == 0` = paste0(
      signif(100 * sum(n_casualty_claims == 0) / n(), 3), "%"
    ),

    `Total Cycling Injury Crashes` = format(sum(n_cyclist_casualty_claims), big.mark = ","),
    `Cycling Injury Crashes == 0` = paste0(
      signif(100 * sum(n_cyclist_casualty_claims == 0) / n(), 3), "%"
    ),

    `Median Cycling Injury Crashes (IQR)` = paste0(
      signif(median(n_cyclist_casualty_claims), 3),
      " (", signif(IQR(n_cyclist_casualty_claims), 3), ")"
    ),

    `Total Pedestrian Injury Crashes` = format(sum(n_pedestrian_casualty_claims), big.mark = ","),

    `Median Pedestrian Injury Crashes (IQR)` = paste0(
      signif(median(n_pedestrian_casualty_claims), 3),
      " (", signif(IQR(n_pedestrian_casualty_claims), 3), ")"
    ),

    `Pedestrian Injury Crashes == 0` = paste0(
      signif(100 * sum(n_pedestrian_casualty_claims == 0) / n(), 3), "%"
    )
 ) %>%
 bind_rows(total_row) %>%
 arrange(match(Region, c("Total Study Area", unique(cma_da_tibble$region)))) %>%
 flextable() %>% 
 add_header_row(
   values = c("", "All", "Cyclist", "Pedestrian"),
   colwidth = c(1, 3, 3, 3)
 ) %>%
 add_footer_lines(values = "DA = Dissemination Area; SD = Standard Deviation") %>%
 set_caption("Table 2. Regional summary statistics for all injury crashes, cyclist involved injury crashes and pedestrian involved crashes.") %>%
 set_table_properties(layout = "autofit", width = 1) %>%
 fontsize(size = 8, part = "all") %>%
 padding(padding = 2, part = "all") %>%
 theme_booktabs() %>%
 fit_to_width(max_width = 15)


table2
save_as_image(table2 %>% autofit(), "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/regional_injury_crashes_descriptive.svg", expand = 1, res = 150)
```


## Road Traffic Injury Inequality

### Table 3 - Incidence Rate Ratios for All Injury Crashes

```{r table 3,fig.width=190/25.4,fig.height=240/25.4}

vandix_irr_all_crashes_models


save_as_docx(vandix_irr_all_crashes_models, path = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/table_3.docx")
save_as_image(vandix_irr_all_crashes_models %>% autofit(), "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/vandix_irr_all_crashes_models.svg", expand = 1, res = 150)




all_irr_fp <- bind_rows(
 all_vandix_irr_unadjusted %>% mutate(Model = "Unadjusted"),
  all_vandix_irr_minimally_adjusted %>% mutate(Model = "Minimally Adjusted"),
  all_vandix_irr_adjusted %>% mutate(Model = "Adjusted")) %>% 
  mutate(Region = factor(region,levels = region_levels %>% rev()),
         Model = factor(Model, levels = c("Unadjusted","Minimally Adjusted","Adjusted"))) %>% 
  ggplot(aes(x = Region, y = irr_mean, color = Model)) +
    geom_hline(yintercept = 1,linetype = "dashed") + 
  geom_point(position = position_dodge(width = 0.5), size = 2) +
  geom_errorbar(aes(ymin = irr_low, ymax = irr_high), 
                 position = position_dodge(width = 0.5), width = 0.5) +
  scale_y_log10() + 
  labs(y = "Incidence Rate Ratio (95% Credible Interval)",
       x = "Region",
       color = "Model",
       title = "All injury crashes") +
  scale_color_ipsum() +
  theme_ipsum_es() + 
  theme(axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
      legend.position = "bottom"
  ) + 
    coord_flip() 

 
ggsave(device = "jpg",
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/vandix_injury_all_irr_forest_plot.jpg",
  plot = all_irr_fp,
  units = "mm",
  height = 190*1.25,
  width = 140*1.25,
  dpi = 600)

all_irr_fp
```


### Table 4 - Incidence Rate Ratios for Cyclist Involved Injury Crashes


```{r table 4,fig.width=190/25.4,fig.height=240/25.4}

vandix_irr_cyclist_crashes_models


save_as_docx(vandix_irr_cyclist_crashes_models, path = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/table_4.docx")
save_as_image(vandix_irr_cyclist_crashes_models %>% autofit(), "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/vandix_irr_cyclist_crashes_models.svg", expand = 1, res = 150)



cyclist_irr_fp <- bind_rows(
 cyclist_vandix_irr_unadjusted %>% mutate(Model = "Unadjusted"),
  cyclist_vandix_irr_minimally_adjusted %>% mutate(Model = "Minimally Adjusted"),
  cyclist_vandix_irr_adjusted %>% mutate(Model = "Adjusted")) %>% 
  mutate(Region = factor(region,levels = region_levels %>% rev()),
         Model = factor(Model, levels = c("Unadjusted","Minimally Adjusted","Adjusted"))) %>% 
  ggplot(aes(x = Region, y = irr_mean, color = Model)) +
    geom_hline(yintercept = 1,linetype = "dashed") + 
  geom_point(position = position_dodge(width = 0.5), size = 2) +
  geom_errorbar(aes(ymin = irr_low, ymax = irr_high), 
                 position = position_dodge(width = 0.5), width = 0.5) +
  scale_y_log10() + 
  labs(y = "Incidence Rate Ratio (95% Credible Interval)",
       x = "Region",
       color = "Model",
       title = "Cyclist-involved injury crashes") +
  scale_color_ipsum() +
  theme_ipsum_es() + 
  theme(axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
      legend.position = "bottom"
  ) + 
  coord_flip() 

ggsave(device = "jpg",
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/vandix_injury_cyclist_irr_forest_plot.jpg",
  plot = cyclist_irr_fp,
  units = "mm",
  height = 190*1.25,
  width = 140*1.25,
  dpi = 600)

cyclist_irr_fp
```

### Table 5 - Incidence Rate Ratios for Pedestrian Involved Injury Crashes

```{r table 5,fig.width=190/25.4,fig.height=240/25.4}

library(hrbrthemes)

vandix_irr_pedestrian_crashes_models
save_as_image(vandix_irr_pedestrian_crashes_models %>% autofit(), "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/vandix_irr_pedestrian_crashes_models.svg", expand = 1, res = 150)


pedestrian_irr_fp <- bind_rows(
 pedestrian_vandix_irr_unadjusted %>% mutate(Model = "Unadjusted"),
  pedestrian_vandix_irr_minimally_adjusted %>% mutate(Model = "Minimally Adjusted"),
  pedestrian_vandix_irr_adjusted %>% mutate(Model = "Adjusted")) %>% 
  mutate(Region = factor(region,levels = region_levels %>% rev()),
         Model = factor(Model, levels = c("Unadjusted","Minimally Adjusted","Adjusted"))) %>% 
  ggplot(aes(x = Region, y = irr_mean, color = Model)) +
    geom_hline(yintercept = 1,linetype = "dashed") + 
  geom_point(position = position_dodge(width = 0.5), size = 2) +
  geom_errorbar(aes(ymin = irr_low, ymax = irr_high), 
                 position = position_dodge(width = 0.5), width = 0.5) +
  scale_y_log10() + 
  labs(y = "Incidence Rate Ratio (95% Credible Interval)",
       x = "Region",
       color = "Model",
       title = "Pedestrian-involved injury crashes") +
  scale_color_ipsum() +
  theme_ipsum_es() + 
  theme(axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
      legend.position = "bottom"
  ) + 
  coord_flip() 

ggsave(device = "jpg",
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/vandix_injury_pedestrian_irr_forest_plot.jpg",
  plot = pedestrian_irr_fp,
  units = "mm",
  height = 190*1.25,
  width = 140*1.25,
  dpi = 600)

pedestrian_irr_fp 


# 
# 
# a <- all_vandix_irr_adjusted %>% 
#   mutate(mode = "All")
# 
# p <- pedestrian_vandix_irr_adjusted %>% 
#   mutate(mode = "Pedestrian")
# 
# 
# 
# c <- cyclist_vandix_irr_adjusted %>% 
#   mutate(mode = "Cyclist") 
# 
# bind_rows(a, p) %>%
#   bind_rows(c) %>%
#   group_by(region) %>%
#   
#   mutate(
#     Region = factor(region, levels = region_levels), pc = irr_mean /
#       irr_mean[1]) %>%
#   select(Region, mode, `IRR (95% CI)`, pc) %>%
#     arrange(Region, mode) %>%
#   print(n = 100)

```

### Figure 2 - Forest Plot of IRRs

```{r,fig.width=190/25.4,fig.height=240/25.4}



all_irr <- bind_rows(
 all_vandix_irr_unadjusted %>% mutate(Model = "Unadjusted"),
  all_vandix_irr_minimally_adjusted %>% mutate(Model = "Minimally\nAdjusted"),
  all_vandix_irr_adjusted %>% mutate(Model = "Adjusted")) %>% 
  mutate(`type` = "All Motor Vehicle")


pedestrian_irr <-    bind_rows(
 pedestrian_vandix_irr_unadjusted %>% mutate(Model = "Unadjusted"),
  pedestrian_vandix_irr_minimally_adjusted %>% mutate(Model = "Minimally\nAdjusted"),
  pedestrian_vandix_irr_adjusted %>% mutate(Model = "Adjusted"))  %>% 
  mutate(`type` = "Pedestrian-Motor Vehicle")

cyclist_irr <-    bind_rows(
 cyclist_vandix_irr_unadjusted %>% mutate(Model = "Unadjusted"),
  cyclist_vandix_irr_minimally_adjusted %>% mutate(Model = "Minimally\nAdjusted"),
  cyclist_vandix_irr_adjusted %>% mutate(Model = "Adjusted"))  %>% 
  mutate(`type` = "Cyclist-Motor Vehicle")

# remotes::install_github("clauswilke/colorblindr")
okabe_ito <- c("#E69F00","#56B4E9","#009E73","#F5C710","#0072B2","#D55E00","#CC79A7","#999999","#000000")

all_modes <- bind_rows(all_irr, cyclist_irr, pedestrian_irr) %>% 
  mutate(Region_formatted = stringr::str_replace_all(region, " ", "\n"),
         Region_formatted = ifelse(region == "Vancouver-Fraser Valley", 
                                  "Vancouver-\nFraser Valley", 
                                  Region_formatted),
         Region = factor(Region_formatted, 
                        levels = sapply(region_levels, function(x) {
                          if(x == "Vancouver-Fraser Valley") {
                            return("Vancouver-\nFraser Valley")
                          } else {
                            return(stringr::str_replace_all(x, " ", "\n"))
                          }
                        })),
         Model = factor(Model, levels = c("Adjusted", "Minimally\nAdjusted", "Unadjusted"))) %>% 
  ggplot(aes(x = Region, y = irr_mean, color = Model)) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "grey30") + 
  geom_point(position = position_dodge(width = 0.75), size = 1) +
  geom_errorbar(aes(ymin = irr_low, ymax = irr_high), 
               position = position_dodge(width = 0.75), width = 0.25) +
  facet_wrap(~type, nrow = 1) +
  scale_y_log10() + 
  labs(y = "Incidence Rate Ratio",
       x = "Region",
       color = "Model") +
  scale_colour_manual(
    values = okabe_ito[c(1,3,5)],
    breaks = c("Unadjusted", "Minimally\nAdjusted", "Adjusted")
  ) +
  theme_ipsum_es(plot_title_size = 12, subtitle_size = 10, base_size = 9) + 
  theme(axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        legend.position = "right",
        panel.spacing = unit(0.5, "lines"),
        plot.margin = margin(5, 7, 5, 5),
        strip.text = element_text(margin = margin(2, 2, 2, 2))
  ) + 
  scale_x_discrete(limits = rev) +
  coord_flip()

all_modes
# colorblindr::cvd_grid(all_modes)

ggsave(device = "jpg",
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/Figure_2.jpg",
  plot = all_modes,
  units = "mm",
  height = 140,
  width = 240,
  dpi = 600)



```


```{r tables}

# Create a new Word document
doc_t <- read_docx(path = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/tables_template.docx")

doc_t <- doc_t %>%
  body_add_flextable(value = table1) %>%body_add_par(value = "") %>%  # Adds an empty paragraph for spacing
  body_add_par(value = "") %>%  # Adding multiple paragraphs increases the space
  body_add_break() %>%
  body_add_flextable(value = table2) %>%
  body_add_par(value = "") %>%  # Adds an empty paragraph for spacing
  body_add_par(value = "") %>%  # Adding multiple paragraphs increases the space
  body_add_break() %>%
  body_add_flextable(value = vandix_irr_all_crashes_models) %>%
  body_add_par(value = "") %>%  # Adds an empty paragraph for spacing
  body_add_par(value = "") %>%  # Adding multiple paragraphs increases the space
  body_add_break() %>%
  body_add_flextable(value = vandix_irr_cyclist_crashes_models) %>%
  body_add_par(value = "") %>%  # Adds an empty paragraph for spacing
  body_add_par(value = "") %>%  # Adding multiple paragraphs increases the space
  body_add_break() %>%
  body_add_flextable(value = vandix_irr_pedestrian_crashes_models) %>%
  body_end_section_landscape()


  
# Save the document
print(doc_t, target = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Tables/Tables Raw.docx")






```

### Figure 3 - Example of Spatial Clustering


```{r}


vfv_da <- cma_da %>%
  # filter(cmaname   == "Vancouver") %>%
  filter(region == "Vancouver-Fraser Valley") %>% 
  st_transform(crs = 26910)

vfv_clusters_all <- vfv_da %>%
  filter(re_all_adjusted_gstar_cluster != "Not significant")
vfv_clusters_cyclists <- vfv_da %>%
  filter(re_cyclist_adjusted_gstar_cluster != "Not significant")
vfv_clusters_pedestrians <- vfv_da %>%
  filter(re_pedestrian_adjusted_gstar_cluster != "Not significant")

 bbox <- st_bbox(vfv_da)

 
bc_boundary_utm <- bc_boundary %>%   st_transform(crs = 26910)

# Add to your existing ggplot
v_all <- ggplot() +
  geom_sf(data = bc_boundary_utm, fill = "grey90") +
  geom_sf(data = vfv_da,
          aes(fill = re_all_adjusted),
          colour = NA) +
  geom_sf(
    data = vfv_clusters_all,
    aes(colour = re_all_adjusted_gstar_cluster),
    fill = NA,
    linewidth = 0.25
  ) +
  scale_fill_gradient2(
    name = expression("Random Effect: "*italic(u[i]) + italic(v[i])) ,
    midpoint = 0,
    high = "#CA562C",
    mid = "#F6EDBD",
    low = "#008080",
    limits = c(-4.75,3.75)
      
  ) +
  scale_colour_manual(name = expression(italic(G)[i]^"✱" * " Cluster"),
                      values = c("darkred", "darkblue", "grey90")
                      ) +
  guides(fill = guide_colorbar(title.vjust = .7,order = 1),
         colour = guide_legend(title.vjust = .7,order = 2, 
                               label.position = "bottom")
         )+
  theme_void(base_size = 10) +
  theme(
    legend.position = "bottom",
    legend.box.margin = margin(10,0,15,0),
    legend.margin = margin(0,60,0,0)#,
    # legend.spacing.x = unit(20, "pt")
    ) + 
  coord_sf(
          xlim = c(bbox$xmin, bbox$xmax),
          ylim = c(bbox$ymin, bbox$ymax)
        ) 
  

# Add to your existing ggplot
v_cyclist <- ggplot() +
  geom_sf(data = bc_boundary_utm, fill = "grey90") +
  geom_sf(data = vfv_da,
          aes(fill = re_cyclist_adjusted),
          colour = NA) +
  geom_sf(
    data = vfv_clusters_cyclists,
    aes(colour = re_cyclist_adjusted_gstar_cluster),
    fill = NA,
    linewidth = 0.25
  ) +
  scale_fill_gradient2(
    name = "Posterior Mean\nof BYM2\nRandom Effect",
    midpoint = 0,
    high = "#CA562C",
    mid = "#F6EDBD",
    low = "#008080",
    limits = c(-4.75,3.75)
      
  ) +
  scale_colour_manual(name = "Gi* Cluster",
                      values = c("darkred", "darkblue", "grey90")) +
  
  theme_void(base_size = 10) +
  theme(
    legend.position = "none",
  ) + 
  coord_sf(
          xlim = c(bbox$xmin, bbox$xmax),
          ylim = c(bbox$ymin, bbox$ymax)
        )

# Add to your existing ggplot
v_pedestrian <- ggplot() +
  geom_sf(data = bc_boundary_utm, fill = "grey90") +
  geom_sf(data = vfv_da,
          aes(fill = re_pedestrian_adjusted),
          colour = NA) +
  geom_sf(
    data = vfv_clusters_pedestrians,
    aes(colour = re_pedestrian_adjusted_gstar_cluster),
    fill = NA,
    linewidth = 0.25
  ) +
  scale_fill_gradient2(
    name = "Posterior Mean\nof BYM2\nRandom Effect",
    midpoint = 0,
    high = "#CA562C",
    mid = "#F6EDBD",
    low = "#008080",
    limits = c(-4.75,3.75)
      
  ) +
  scale_colour_manual(name = "Gi* Cluster",
                      values = c("darkred", "darkblue", "grey90")) +
  
  theme_void(base_size = 10) +
  theme(
   legend.position = "none"
  ) + 
  coord_sf(
          xlim = c(bbox$xmin, bbox$xmax),
          ylim = c(bbox$ymin, bbox$ymax)
        )


legend <- cowplot::get_plot_component(v_all, 'guide-box-bottom',return_all = TRUE)

re_map <- plot_grid(
  v_all + theme(legend.position = "none"),
  v_cyclist,
  v_pedestrian,
  legend,  # Adjust the legend panel to shift it off-center (right)
  ncol = 1,
  labels = c("A","B","C",""),
  rel_heights = c(1,1,1,0.18),
  vjust = 1.5,
  hjust = -.8,
  label_x = .001,label_size = 16
)


ggsave(device = "jpg",
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/Figure_3.jpg",
  plot = re_map,
  units = "mm",
  height = 195,
  width = 190,
  dpi = 300)


```

#### DA Size and Random Effect

```{r}
ggplot(cma_da,aes(x=log(population/landarea),y=re_all_adjusted)) + 
  geom_hline(yintercept = 0,linetype ="dashed") + 
  geom_point(alpha=0.25) + 
  stat_smooth(method = "lm",colour="darkred") + 
  scale_y_continuous(limits = c(-5,4))


tidy(lm(re_all_adjusted ~ log(population/landarea),data = cma_da))


ggplot(cma_da,aes(x=log(population/landarea),y=re_cyclist_adjusted)) + 
  geom_hline(yintercept = 0,linetype ="dashed") + 
  geom_point(alpha=0.25) + 
  stat_smooth(method = "lm",colour="darkred") + 
  scale_y_continuous(limits = c(-5,4))


tidy(lm(re_cyclist_adjusted ~ log(population/landarea),data = cma_da))

ggplot(cma_da,aes(x=log(population/landarea),y=re_pedestrian_adjusted)) + 
  geom_hline(yintercept = 0,linetype ="dashed") + 
  geom_point(alpha=0.25) + 
  stat_smooth(method = "lm",colour="darkred") + 
  scale_y_continuous(limits = c(-5,4))

tidy(lm(re_pedestrian_adjusted ~ log(population/landarea),data = cma_da))










```


# Supplementary Material 1

## Spatial Distribution of Inputs and Outputs

### Static Maps

```{r static maps}

# Helper function to create map configurations
#Each config specifies:
# The variable to map (fill_var)
# Title for the map
# Color palette to use
# Whether the data is continuous or discrete
create_map_configs <- function() {
  list(
    all_injury = list(
      fill_var = "n_casualty_claims",
      title = "All Injury Crashes",
      palette = "BrwnYl",
      type = "continuous"
    ),
    cyclist_injury = list(
      fill_var = "n_cyclist_casualty_claims",
      title = "Cyclist Injury Crashes",
      palette = "BrwnYl",
      type = "continuous"
    ),
    pedestrian_injury = list(
      fill_var = "n_pedestrian_casualty_claims",
      title = "Pedestrian Injury Crashes",
      palette = "BrwnYl",
      type = "continuous"
    ),
    vandix = list(
      fill_var = "vandix_z",
      title = "VanDIX (sd)",
      palette = "custom",
      type = "continuous"
    ),
    lane_length = list(
      fill_var = "total_lane_length_km",
      title = "Kilometres Lane Length",
      palette = "BluYl",
      type = "continuous"
    ),
    arterial_highway = list(
      fill_var = "roads_prop_highway_arterial",
      title = "Proportion of Major Roads",
      palette = "BluYl",
      type = "continuous"
    ),
    intersections = list(
      fill_var = "number_intersections",
      title = "Number of Intersections",
      palette = "BluYl",
      type = "continuous"
    ),
    bike_infra = list(
      fill_var = "bike_infra_cat",
      title = "Bicycle Infrastructure",
      palette = "Safe",
      type = "discrete"
    ),
    population = list(
      fill_var = "population_100",
      title = "Population (100s)",
      palette = "Magenta",
      type = "continuous"
    ),
    all_injury_bym2 = list(
      fill_var = "re_all_adjusted",
      title = "Adjusted Model for All Injury Crashes",
      palette = "bym2",
      type = "continuous"
    ),
    cyclist_injury_bym2 = list(
      fill_var = "re_cyclist_adjusted",
      title = "Adjusted Model for Cyclist-Involved Injury Crashes",
      palette = "bym2",
      type = "continuous"
    ),
    pedestrian_injury_bym2 = list(
      fill_var = "re_pedestrian_adjusted",
      title = "Adjusted Model for Pedestrian-Involved Injury Crashes",
      palette = "bym2",
      type = "continuous"
    ),
     all_injury_bym2 = list(
      fill_var = "re_all_adjusted_gstar_cluster",
      title = "Gi* Clustering for Adjusted BYM2 Random Effect: All Injury Crashes",
      palette = "Safe",
      type = "discrete"
    ),
    cyclist_injury_bym2 = list(
      fill_var = "re_cyclist_adjusted_gstar_cluster",
      title = "Gi* Clustering for Adjusted BYM2 Random Effect: Cyclist Injury Crashes",
      palette = "Safe",
      type = "discrete"
    ),
    pedestrian_injury_bym2 = list(
      fill_var = "re_pedestrian_adjusted_gstar_cluster",
      title = "Gi* Clustering for Adjusted BYM2 Random Effect: Pedestrian Injury Crashes",
      palette = "Safe",
      type = "discrete"
    )
    
    
  )
}


# Create single map function
create_map <- function(region, config, bc_boundary) {
  bbox <- st_bbox(region)
  
  base_map <- ggplot() +
    geom_sf(data = bc_boundary, fill = "grey50") +
    theme_void() +
    ggtitle(paste0(region$region[1], if (grepl("Adjusted Model", config$title))
      paste0(": ", config$title)
      else
        "")) +
    theme(
      legend.position = "bottom",
      panel.border = element_rect(
        color = "black",
        fill = NA,
        linewidth = 1
      )
    ) +
    annotation_scale()
  
  # Add specific fill and scale based on config
  if (config$type == "continuous") {
    if (config$palette == "custom" && config$title == "VanDIX (sd)") {
      base_map +
        geom_sf(
          data = region,
          aes(fill = !!sym(config$fill_var)),
          colour = "grey90",
          linewidth = 0.05
        ) +
        scale_fill_gradient2(
          name = config$title,
          midpoint = 0,
          high = "#724e06",
          mid = "#EDEAC2",
          low = "#008080"
        ) +
        coord_sf(
          xlim = c(bbox$xmin, bbox$xmax),
          ylim = c(bbox$ymin, bbox$ymax)
        )
    } else if (config$palette == "bym2") {
      base_map +
        geom_sf(
          data = region,
          aes(fill = !!sym(config$fill_var)),
          colour = "grey70",
          linewidth = 0.05
        ) +
        scale_fill_gradient2(
          name = "Posterior Mean of BYM2 Random Effect",
          midpoint = 0,
          high = "#CA562C",
          mid = "#F6EDBD",
          low = "#008080"
        ) +
        coord_sf(
          xlim = c(bbox$xmin, bbox$xmax),
          ylim = c(bbox$ymin, bbox$ymax)
        )
    } else {
      base_map +
        geom_sf(
          data = region,
          aes(fill = !!sym(config$fill_var)),
          colour = "grey70",
          linewidth = 0.05
        ) +
        scale_fill_carto_c(
          name = config$title,
          palette = config$palette,
          direction = 1
        ) +
        coord_sf(
          xlim = c(bbox$xmin, bbox$xmax),
          ylim = c(bbox$ymin, bbox$ymax)
        )
    }
  } else {
    base_map +
      geom_sf(
        data = region,
        aes(fill = !!sym(config$fill_var)),
        colour = "grey50",
        linewidth = 0.05
      ) +
      scale_fill_carto_d(name = config$title, palette = config$palette) +
      coord_sf(xlim = c(bbox$xmin, bbox$xmax),
               ylim = c(bbox$ymin, bbox$ymax))
  }
}


# Main function to create all maps for a region
plot_maps <- function(region, bc_boundary) {
  configs <- create_map_configs()
  map(configs, ~ create_map(region, ., bc_boundary))
}

captions <- c(
  "All injury crashes" ,
  "Cyclist injury crashes",
  "Pedestrian injury crashes",
  "Vancouver Area Deprivation Index (VanDIX)",
  "Total Lane Kilometres",
  "Proportion of Total Lane Kilometres classified as Arterial or Highway",
  "Number of Intersections",
  "Presence of Bike Infrastructure from Canadian Bikeway Comfort and Safety Classification (CanBICS)",
  "Population",
  "Adjusted Model BYM2 Random Effect for Injury Crashes",
  "Adjusted Model BYM2 Random Effect for Cyclist Involved Injury Crashes",
  "Adjusted Model BYM2 Random Effect for Pedestrian Involved Injury Crashes",
  "Adjusted Model BYM2 Random Effect for Injury Crashes - Gi* Clusters",
  "Adjusted Model BYM2 Random Effect for Cyclist Involved Injury Crashes-Gi* Clusters",
  "Adjusted Model BYM2 Random Effect for Pedestrian Involved Injury Crashes-Gi* Clusters"
  
)

# Function to save maps and add to document
process_region <- function(region_maps,
                           region_name,
                           doc,
                           captions,
                           figure_num,
                           orientation,
                           width,
                           height,
                           base_path) {
  # Determine dimensions based on orientation
  dims <- if (orientation == "landscape") {
    list(height = width - 0.827, width = height)
  } else {
    list(height = height - 0.5, width = width)
  }
  
  # Process each map in the region
  for (i in seq_along(region_maps)) {
    # Save map
    filename <- file.path(base_path,
                          paste0(tolower(gsub(
                            " ", "_", region_name
                          )), "_descriptive_map_", i, ".jpg"))
    ggsave(
      region_maps[[i]],
      filename = filename,
      units = "in",
      height = dims$height,
      width = dims$width,
      dpi = 150
    )
    
    # Add to document
    doc <- doc %>%
      body_add_gg(
        value = region_maps[[i]],
        width = dims$width,
        height = dims$height,
        res = 150
      ) %>%
      body_add_par(
        paste0(
          "Figure ",
          figure_num + i,
          ": ",
          captions[i],
          " by Dissemination Area in the ",
          region_name,
          " Region"
        ),
        style = "caption"
      )
  }
  
  # End section with appropriate orientation
  doc <- doc %>%
    body_end_section_portrait_landscape(orientation)
  
  list(doc = doc, figure_num = figure_num + length(region_maps))
}

# Helper function to end section with appropriate orientation
body_end_section_portrait_landscape <- function(doc, orientation) {
  if (orientation == "landscape") {
    doc %>% body_end_section_landscape()
  } else {
    doc %>% body_end_section_portrait()
  }
}

# Main execution
main <- function() {
  # Create configs for region orientations
  region_orientations <- list(
    "Vancouver-Fraser Valley" = "landscape",
    "Victoria" = "landscape",
    "Okanagan" = "portrait",
    "Central Island" = "landscape",
    "Northeast" = "portrait",
    "Kamloops" = "landscape",
    "Campbell River" = "portrait",
    "Parksville" = "landscape",
    "Cranbrook" = "portrait",
    "Squamish" = "portrait",
    "Terrace" = "portrait",
    "Salmon Arm" = "portrait",
    "Nelson" = "landscape",
    "Powell River" = "landscape",
    "Trail" = "portrait",
    "Prince Rupert" = "portrait"
  )
  
  # Initialize document
  doc_sm <- read_docx(path = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Supplementary Material/sm_template_1.docx")
  word_size <- docx_dim(doc_sm)
  width <- word_size$page['width'] - word_size$margins['left'] - word_size$margins['right']
  height <- word_size$page['height'] - word_size$margins['top'] - word_size$margins['bottom']
  
  region_da_list <- cma_da %>% split(.$region)
  
  # Create maps for# Create maps for# Create maps for all regions
  maps <- map(region_da_list, ~ plot_maps(., bc_boundary))
  
  # Process each region
  figure_num <- 0
  for (region_name in names(maps)) {
    result <- process_region(
      maps[[region_name]],
      region_name,
      doc_sm,
      captions,
      figure_num,
      region_orientations[[region_name]],
      width,
      height,
      "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Supplementary Material/Figures"
    )
    doc_sm <- result$doc
    figure_num <- result$figure_num
  }
  
  # Save final document
  print(doc_sm, target = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Supplementary Material/Supplementary Material 1.docx")
}

main()
```


### Interactive Map

```{r dynamic map}

library(htmltools)  # For HTML() function

regions <- cma_da %>%
  group_by(region_name) %>%
  summarise(n = n())


nb_colours <- 16
colour_pal <- colorRampPalette(carto_pal(12, "Antique"))(nb_colours)
dark2_pal <- RColorBrewer::brewer.pal(8,name = "Dark2")[c(8,1)]
cluster_pal <- c("darkred","darkblue","grey90")

create_interactive_map <- function(cma_da) {

  # Transform to WGS84 for leaflet
  cma_da_wgs84 <- st_transform(cma_da, 4326)
  regions_wgs84 <- st_transform(regions, 4326)
  
  # Create distinct color palettes for different types of variables
  # Crash counts - Red scheme
  pal_crashes <- colorNumeric(palette = "Reds",
                              domain = NULL,
                              na.color = "transparent")
  
  # Built environment - Blue scheme
  pal_built_env <- colorNumeric(palette = "YlGnBu",
                                domain = NULL,
                                na.color = "transparent")
  
  
  # VanDIX - Diverging RdBu scheme with standard deviation breaks
  pal_vandix <- colorBin(
    palette = "RdYlBu",
    reverse = TRUE,
    domain = cma_da_wgs84$vandix_z,
    bins = c(-Inf, -4, -3, -2, -1, 0, 1, 2, 3, 4, Inf),
    na.color = "transparent"
  )
  
  # Population - Purple scheme
  pal_pop <- colorNumeric(
    palette = "Purples",
    domain = cma_da_wgs84$population,
    # Convert back to actual population
    na.color = "transparent"
  )
  
  # BYM2 models - Diverging RdBu scheme
  pal_bym2 <- colorNumeric(
    palette = "RdBu",
    reverse = TRUE,
    domain = c(min(
      c(
        cma_da_wgs84$re_all_adjusted,
        cma_da_wgs84$re_cyclist_adjusted,
        cma_da_wgs84$re_pedestrian_adjusted
      ),
      na.rm = TRUE
    ), max(
      c(
        cma_da_wgs84$re_all_adjusted,
        cma_da_wgs84$re_cyclist_adjusted,
        cma_da_wgs84$re_pedestrian_adjusted
      ),
      na.rm = TRUE
    )),
    na.color = "transparent"
  )
  
  # Create layer descriptions
  layer_descriptions <- list(
    "Region" = "Distinct spatially contiguous region within the study area. Each color represents a different administrative zone.",
    "Population" = "Total resident population in each dissemination area based on 2021 Canadian census.",
    "All Injury Crashes" = "Total motor vehicle injury crashes captured by auto-insurance data (2019-2023).",
    "Cyclist Injury Crashes" = "Total bicycle-motor vehicle injury crashes captured by auto-insurance data (2019-2023).",
    "Pedestrian Injury Crashes" = "Total pedestrian-motor vehicle injury crashes captured by auto-insurance data (2019-2023)",
    "VanDIX" = "Vancouver Area Deprivation Index (z-scores). Higher values (red) indicate higher levels of socioeconomic deprivation.",
    "Lane Length" = "Total road lane length in kilometers within each dissemination area.",
    "Major Roads" = "Proportion of major road lanes (highways/freeways and arterials) as a percentage of total lane length.",
    "Intersections" = "Number of intersections within each dissemination area",
    "Cycling Infrastructure" = "Presence or absence of bicycling specific infrastructure derived from The OpenStreetMap based Canadian Bikeway Comfort and Safety (Can-BICS) Classification System.",
    "BYM2 Random Effect - All Injuries" = "Modified Besag-York-Mollie (BYM2) random effect is the sum of spatial and unstructured random effects on log scale. Values greater than 0 indicate neighbourhoods with more injury crashes than expected after adjusting for explanatory variables in the adjusted model; values less than 0 indicate fewer crashes than expected.",
    "BYM2 Random Effect - All Injuries - Clusters" = "Significant spatial clusters of the BYM2 random effect for adjusted all injury crash model, identified using the Getis-Ord Gi statistic. The Gi statistic indicates areas where high or low values are surrounded by similar values. Statistical significance was assessed using Monte-Carlo simulation with 99,999 permutations and a threshold of 0.001, tested against the null hypothesis of complete spatial randomness. Red clusters represent areas with significantly higher BYM2 values (more injury crashes than expected) after accounting for deprivation and built environment factors, while blue clusters indicate significantly lower BYM2 values (fewer crashes than expected)",
    "BYM2 Random Effect - Cyclists" = "Modified Besag-York-Mollie (BYM2) random effect is the sum of spatial and unstructured random effects on log scale. Values greater than 0 indicate neighbourhoods with more injury crashes than expected after adjusting for explanatory variables in the adjusted model; values less than 0 indicate fewer crashes than expected.",
    "BYM2 Random Effect - Cyclists - Clusters" = "Significant spatial clusters of the BYM2 random effect for adjusted cyclist injury crash model, identified using the Getis-Ord Gi statistic. The Gi statistic indicates areas where high or low values are surrounded by similar values. Statistical significance was assessed using Monte-Carlo simulation with 99,999 permutations and a threshold of 0.001, tested against the null hypothesis of complete spatial randomness. Red clusters represent areas with significantly higher BYM2 values (more injury crashes than expected) after accounting for deprivation and built environment factors, while blue clusters indicate significantly lower BYM2 values (fewer crashes than expected)",
    "BYM2 Random Effect - Pedestrians" = "Modified Besag-York-Mollie (BYM2) random effect is the sum of spatial and unstructured random effects on log scale. Values greater than 0 indicate neighbourhoods with more injury crashes than expected after adjusting for explanatory variables in the adjusted model; values less than 0 indicate fewer crashes than expected.",
    "BYM2 Random Effect - Pedestrians - Clusters" = "Significant spatial clusters of the BYM2 random effect for adjusted pedestrian injury crash model, identified using the Getis-Ord Gi statistic. The Gi statistic indicates areas where high or low values are surrounded by similar values. Statistical significance was assessed using Monte-Carlo simulation with 99,999 permutations and a threshold of 0.001, tested against the null hypothesis of complete spatial randomness. Red clusters represent areas with significantly higher BYM2 values (more injury crashes than expected) after accounting for deprivation and built environment factors, while blue clusters indicate significantly lower BYM2 values (fewer crashes than expected)"
  )
  
  # Function to create HTML title with description
  create_title_with_desc <- function(layer_name) {
    return(paste0(
      "<strong>", layer_name, "</strong>",
      "<br><span style='font-size: 0.85em; font-weight: normal;'>", 
      layer_descriptions[[layer_name]], 
      "</span>"
    ))
  }
  
  # Create color palette function for regions
  pal_region <- colorFactor(palette = colour_pal, domain = cma_da_wgs84$region)
  pal_cycling_infrastructure <- colorFactor(palette = dark2_pal, domain = cma_da_wgs84$bike_infra_cat)
  pal_cluster <- colorFactor(palette = cluster_pal, domain = cma_da_wgs84$re_all_adjusted_gstar_cluster)

  # Create base map
  m <- leaflet(cma_da_wgs84) %>%
    # Add base tiles
    addTiles(group = "OpenStreetMap") %>%
    addProviderTiles(providers$CartoDB.Positron, group = "CartoDB") %>%
    addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
    # Add polygons
    addPolygons(
      fillColor = ~ pal_region(region),
      weight = 0.5,
      opacity = 1,
      color = pal_region,
      fillOpacity = 0.7,
      popup = ~ paste0("Region: ", region),
      # Added region value to popup
      group = "Region"
    ) %>%
    # Add legend
    addLegend(
      position = "bottomright",
      pal = pal_region,
      values = ~ region,
      title = HTML(create_title_with_desc("Region")),
      opacity = 0.9,
      group = "Region"
    ) %>%  
    addScaleBar(
      position = "bottomleft",
      options = scaleBarOptions(metric = TRUE, imperial = FALSE)
    )
  
  # Population Layer
  m <- m %>%
    addPolygons(
      fillColor = ~ pal_pop(population),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>Population:</strong> ",
        formatC(
          population,
          format = "f",
          big.mark = ",",
          digits = 0
        )
      ),
      group = "Population"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_pop,
      values = ~ population_100 * 100,
      title = HTML(create_title_with_desc("Population")),
      opacity = 0.7,
      group = "Population",
      labFormat = labelFormat(big.mark = ",")
    )
  
  # 1. Crash Counts
  m <- m %>%
    # All injuries
    addPolygons(
      fillColor = ~ pal_crashes(n_casualty_claims),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>All Injury Crashes:</strong> ",
        round(n_casualty_claims, 1)
      ),
      group = "All Injury Crashes"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_crashes,
      values = ~ n_casualty_claims,
      title = HTML(create_title_with_desc("All Injury Crashes")),
      opacity = 0.7,
      group = "All Injury Crashes"
    ) %>%
    # Cyclist injuries
    addPolygons(
      fillColor = ~ pal_crashes(n_cyclist_casualty_claims),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>Cyclist Injury Crashes:</strong> ",
        round(n_cyclist_casualty_claims, 1)
      ),
      group = "Cyclist Injury Crashes"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_crashes,
      values = ~ n_cyclist_casualty_claims,
      title = HTML(create_title_with_desc("Cyclist Injury Crashes")),
      opacity = 0.7,
      group = "Cyclist Injury Crashes"
    ) %>%
    # Pedestrian injuries
    addPolygons(
      fillColor = ~ pal_crashes(n_pedestrian_casualty_claims),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>Pedestrian Injury Crashes:</strong> ",
        round(n_pedestrian_casualty_claims, 1)
      ),
      group = "Pedestrian Injury Crashes"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_crashes,
      values = ~ n_pedestrian_casualty_claims,
      title = HTML(create_title_with_desc("Pedestrian Injury Crashes")),
      opacity = 0.7,
      group = "Pedestrian Injury Crashes"
    )
  
  # 2. Built Environment Features
  m <- m %>%
    # VanDIX
    addPolygons(
      fillColor = ~ pal_vandix(vandix_z),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0("<strong>VanDIX (sd):</strong> ", round(vandix_z, 2)),
      group = "VanDIX"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_vandix,
      values = ~ vandix_z,
      title = HTML(create_title_with_desc("VanDIX")),
      opacity = 0.7,
      group = "VanDIX"
    ) %>%
    # Lane length
    addPolygons(
      fillColor = ~ pal_built_env(total_lane_length_km),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>Lane Length (km):</strong> ",
        round(total_lane_length_km, 1)
      ),
      group = "Lane Length"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_built_env,
      values = ~ total_lane_length_km,
      title = HTML(create_title_with_desc("Lane Length")),
      opacity = 0.7,
      group = "Lane Length"
    ) %>%
    # Major roads proportion
    addPolygons(
      fillColor = ~ pal_built_env(roads_prop_highway_arterial),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>Proportion Major Roads:</strong> ",
        round(roads_prop_highway_arterial * 100, 1),
        "%"
      ),
      group = "Major Roads"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_built_env,
      values = ~ roads_prop_highway_arterial,
      title = HTML(create_title_with_desc("Major Roads")),
      opacity = 0.7,
      group = "Major Roads"
    ) %>%
    # Intersections
    addPolygons(
      fillColor = ~ pal_built_env(number_intersections),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0("<strong>Intersections:</strong> ", number_intersections),
      group = "Intersections"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_built_env,
      values = ~ number_intersections,
      title = HTML(create_title_with_desc("Intersections")),
      opacity = 0.7,
      group = "Intersections"
    ) 
  
  
  m <- m %>% 
     addPolygons(
      fillColor = ~ pal_cycling_infrastructure(bike_infra_cat),
      weight = 0.5,
      opacity = 1,
      color = pal_cycling_infrastructure,
      fillOpacity = 0.7,
      popup = ~ paste0("Cycling Infrastructure: ", bike_infra_cat),
      # Added region value to popup
      group = "Cycling Infrastructure"
    ) %>%
    # Add legend
    addLegend(
      position = "bottomright",
      pal = pal_cycling_infrastructure,
      values = ~ bike_infra_cat,
      title = HTML(create_title_with_desc("Cycling Infrastructure")),
      opacity = 0.9,
      group ="Cycling Infrastructure"
    )
  
  # 3. BYM2 Model Results
  m <- m %>%
    # All injury model
    addPolygons(
      fillColor = ~ pal_bym2(re_all_adjusted),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>BYM2 Random Effect (All Injuries)</strong><br>",
        "Value: ",
        round(re_all_adjusted, 2),
        "<br>",
        "Values > 0 indicate higher than expected crash incidence<br>",
        "Values < 0 indicate lower than expected crash incidence"
      ),
      group = "BYM2 Random Effect - All Injuries"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_bym2,
      values = ~ re_all_adjusted,
      title = HTML(create_title_with_desc("BYM2 Random Effect - All Injuries")),
      opacity = 0.7,
      group = "BYM2 Random Effect - All Injuries"
    ) %>%
    # Cyclist model
    addPolygons(
      fillColor = ~ pal_bym2(re_cyclist_adjusted),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>BYM2 Random Effect (Cyclist Injuries)</strong><br>",
        "Value: ",
        round(re_cyclist_adjusted, 2),
        "<br>",
        "Values > 0 indicate higher than expected crash incidence<br>",
        "Values < 0 indicate lower than expected crash incidence"
      ),
      group = "BYM2 Random Effect - Cyclists"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_bym2,
      values = ~ re_cyclist_adjusted,
      title = HTML(create_title_with_desc("BYM2 Random Effect - Cyclists")),
      opacity = 0.7,
      group = "BYM2 Random Effect - Cyclists"
    ) %>%
    # Pedestrian model
    addPolygons(
      fillColor = ~ pal_bym2(re_pedestrian_adjusted),
      weight = 0.5,
      opacity = 1,
      color = "white",
      fillOpacity = 0.7,
      popup = ~ paste0(
        "<strong>BYM2 Random Effect (Pedestrian Injuries)</strong><br>",
        "Value: ",
        round(re_pedestrian_adjusted, 2),
        "<br>",
        "Values > 0 indicate higher than expected crash incidence<br>",
        "Values < 0 indicate lower than expected crash incidence"
      ),
      group = "BYM2 Random Effect - Pedestrians"
    ) %>%
    addLegend(
      position = "bottomright",
      pal = pal_bym2,
      values = ~ re_pedestrian_adjusted,
      title = HTML(create_title_with_desc("BYM2 Random Effect - Pedestrians")),
      opacity = 0.7,
      group = "BYM2 Random Effect - Pedestrians"
    )
  
    # 4. BYM2 Model Clustering
    
  m <- m %>% 
     addPolygons(
      fillColor = ~ pal_cluster(re_all_adjusted_gstar_cluster),
      weight = 0.5,
      opacity = 1,
      color = pal_cluster,
      fillOpacity = 0.7,
      popup = ~ paste0("Significant Clustering: ", re_all_adjusted_gstar_cluster),
      # Added region value to popup
      group = "BYM2 Random Effect - All Injuries - Clusters"
    ) %>%
    # Add legend
    addLegend(
      position = "bottomright",
      pal = pal_cluster,
      values = ~ re_all_adjusted_gstar_cluster,
      title = HTML(create_title_with_desc("BYM2 Random Effect - All Injuries - Clusters")),
      opacity = 0.9,
      group = "BYM2 Random Effect - All Injuries - Clusters"
    )
  
      
  m <- m %>% 
     addPolygons(
      fillColor = ~ pal_cluster(re_cyclist_adjusted_gstar_cluster),
      weight = 0.5,
      opacity = 1,
      color = pal_cluster,
      fillOpacity = 0.7,
      popup = ~ paste0("Significant Clustering: ", re_cyclist_adjusted_gstar_cluster),
      # Added region value to popup
      group = "BYM2 Random Effect - Cyclists - Clusters"
    ) %>%
    # Add legend
    addLegend(
      position = "bottomright",
      pal = pal_cluster,
      values = ~ re_cyclist_adjusted_gstar_cluster,
      title = HTML(create_title_with_desc("BYM2 Random Effect - Cyclists - Clusters")),
      opacity = 0.9,
      group = "BYM2 Random Effect - Cyclists - Clusters"
    )
  
      
  m <- m %>% 
     addPolygons(
      fillColor = ~ pal_cluster(re_pedestrian_adjusted_gstar_cluster),
      weight = 0.5,
      opacity = 1,
      color = pal_cluster,
      fillOpacity = 0.7,
      popup = ~ paste0("Significant Clustering: ", re_pedestrian_adjusted_gstar_cluster),
      # Added region value to popup
      group = "BYM2 Random Effect - Pedestrians - Clusters"
    ) %>%
    # Add legend
    addLegend(
      position = "bottomright",
      pal = pal_cluster,
      values = ~ re_pedestrian_adjusted_gstar_cluster,
      title = HTML(create_title_with_desc("BYM2 Random Effect - Pedestrians - Clusters")),
      opacity = 0.9,
      group = "BYM2 Random Effect - Pedestrians - Clusters"
    )
  
  # Add layer controls with grouped variables and Population after Intersections
  m <- m %>%
    addLayersControl(
      baseGroups = c("CartoDB", "OpenStreetMap", "Satellite"),
      overlayGroups = c(
        "Region",
        # Crash counts
        "All Injury Crashes",
        "Cyclist Injury Crashes",
        "Pedestrian Injury Crashes",
        # Built environment
        "VanDIX",
        "Lane Length",
        "Major Roads",
        "Intersections",
        "Cycling Infrastructure",
        # Population
        "Population",
        # Model results
        "BYM2 Random Effect - All Injuries",
        "BYM2 Random Effect - All Injuries - Clusters",
        "BYM2 Random Effect - Cyclists",
        "BYM2 Random Effect - Cyclists - Clusters",
        "BYM2 Random Effect - Pedestrians",
        "BYM2 Random Effect - Pedestrians - Clusters"
        
      ),
      options = layersControlOptions(collapsed = TRUE, groupCheckboxes = TRUE),
      position = "topleft"
    ) %>%
    # Hide all layers except All Injury Crashes
    hideGroup(
      c(
        "All Injury Crashes",
        "Cyclist Injury Crashes",
        "Pedestrian Injury Crashes",
        "VanDIX",
        "Lane Length",
        "Major Roads",
        "Intersections",
        "Cycling Infrastructure",
        "Population",
        "BYM2 Random Effect - All Injuries",
        "BYM2 Random Effect - All Injuries - Clusters",
        "BYM2 Random Effect - Cyclists",
                "BYM2 Random Effect - Cyclists - Clusters",
        "BYM2 Random Effect - Pedestrians",
                "BYM2 Random Effect - Pedestrians - Clusters"
      )
    ) %>%
    # Add CSS to improve the legend styling
    htmlwidgets::onRender("
      function(el, x) {
        // Add some CSS to make legends more readable
        var css = document.createElement('style');
        css.type = 'text/css';
        css.innerHTML = `
          .info.legend {
            max-width: 300px;
            line-height: 1.4;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 10px;
            border-radius: 5px;
          }
          .info.legend span {
            display: block;
            margin-bottom: 8px;
            text-align: left;
          }
        `;
        document.head.appendChild(css);
      }
    ")
  
  return(m)
}

# Create and save the map
map <- create_interactive_map(cma_da)
# map
# Save with custom HTML template to ensure proper initial state
saveWidget(
  map,
  "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Supplementary Material/Supplementary Material 1/index.html",
  selfcontained = TRUE,
  title = "Spatial Distribution of BYM2 Models Inputs and Outputs"
)
```


# Supplementary Material 2
### Figure 1 - VanDIX Ridgeline


```{r sm figure 1, fig.height=12.75591,fig.width=10.09843}
table2_data <- cma_da_tibble %>%
  mutate(
    vandix_z_c = cut(
      vandix_z,
      breaks = c(-Inf, -1, 0, 1,Inf),  # Changed breaks to include all values
      right = TRUE,
      include.lowest = TRUE,
      ordered_result = TRUE,
      labels = c("< -1", "-1 to 0", "0 to 1", ">1")
    )
  ) %>% 
  group_by(vandix_z_c) %>%
  mutate(
    across(contains("prev"), ~ . * 100),
    average_total_income_of_household_in_2020 = average_total_income_of_household_in_2020/1000
  ) %>%
  rename(
    "VANDIX Z-Score" = vandix_z_c,
    "No High School (%)" = no_highschool_prevalence,
    "Unemployment Rate (%)" = unemployment_rate,
    "Average Household Income ($1000s)" = average_total_income_of_household_in_2020,
    "Labor Force Participation (%)" = participation_rate,
    "University Degree (%)" = university_degree_prevalence,
    "Single Parent Families (%)" = lone_parent_fam_prevalence,
    "Home Ownership (%)" = home_owner_prevalence
  ) %>%
  select(
    "VANDIX Z-Score",
    "No High School (%)",
    "Unemployment Rate (%)",
    "University Degree (%)",
    "Single Parent Families (%)",
    "Average Household Income ($1000s)",
    "Home Ownership (%)",
    "Labor Force Participation (%)"
  ) %>% 
    summarizor(by = c("VANDIX Z-Score"))




table2 <- table2_data %>%
  as_flextable(spread_first_col = TRUE) %>%
  bold(part = "body", i = seq(1, 28, by = 4)) %>%
  set_caption(
    "Table 2. Summary Statistics for each component of VanDIX score across one standard deviation change in the score."
  ) %>%
  autofit() %>%
  theme_booktabs()

table2

 
vandix_distribution <-  cma_da_tibble %>%
   mutate(
     vandix_z_c = cut(
       vandix_z,
       breaks = c(-Inf, -1, 0, 1, Inf),
       # Changed breaks to include all values
       right = TRUE,
       include.lowest = TRUE,
       ordered_result = TRUE,
       labels = c("< -1", "-1 to 0", "0 to 1", ">1")
     )
   ) %>%
   group_by(vandix_z_c) %>%
   mutate(across(contains("prev"), ~ . * 100),
          average_total_income_of_household_in_2020 = average_total_income_of_household_in_2020 /
            10000) %>%
   rename(
     "VanDIX Z-Score" = vandix_z_c,
     "No High School (%)" = no_highschool_prevalence,
     "Unemployment Rate (%)" = unemployment_rate,
     "Average Household Income ($10k)" = average_total_income_of_household_in_2020,
     "Labor Force Participation (%)" = participation_rate,
     "University Degree (%)" = university_degree_prevalence,
     "Single Parent Families (%)" = lone_parent_fam_prevalence,
     "Home Ownership (%)" = home_owner_prevalence
   ) %>%
   select(
     "VanDIX Z-Score",
     "No High School (%)",
     "Unemployment Rate (%)",
     "University Degree (%)",
     "Single Parent Families (%)",
     "Average Household Income ($10k)",
     "Home Ownership (%)",
     "Labor Force Participation (%)"
   ) %>%
   pivot_longer(cols = contains("%") | contains("$")) %>%
   mutate(name = factor(
     name,
     levels = c(
       "No High School (%)",
       "Unemployment Rate (%)",
       "University Degree (%)",
       "Single Parent Families (%)",
       "Average Household Income ($10k)",
       "Home Ownership (%)",
       "Labor Force Participation (%)"
     )
   )) %>%
   group_by(`VanDIX Z-Score`, name) %>%
   ggplot(aes(y = `VanDIX Z-Score`, x = value, fill = factor(stat(quantile)))) +
   stat_density_ridges(
     geom = "density_ridges_gradient",
     calc_ecdf = TRUE,
     quantiles = 4,
     quantile_lines = TRUE,
     rel_min_height = 0.01,
      scale = 2,
   ) +
   scale_fill_carto_d(name = "Quartiles", palette = "Geyser") + 
   facet_wrap(~ name, scales = "free_x", ncol = 1) +
   theme_ipsum_es(axis_title_size = 12,
                              grid = "XxYy",
                              ticks = TRUE) +
     theme(panel.spacing = unit(0.001, "lines")) +
   ylab("VanDIX Score (Higher = Greater Deprivation)") +
   xlab("Value") +
   xlim(0, 100)
 
 ggsave(device = "svg",
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/vandix_components_distribution.svg",
  plot = vandix_distribution,
  units = "mm",
  height = 240*1.35,
  width = 190*1.35)

 
ggsave(device = "jpg",
  filename = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Figures/vandix_components_distribution.jpg",
  plot = vandix_distribution,
  units = "mm",
  height = 240*1.35,
  width = 190*1.35,
  dpi = 600)


 vandix_distribution
```


## Table 1 - Model Comparison of Fit Metrics

```{r waic vs dic}

all_crashes_comparison <- model_selection_all %>%
  mutate(
    Model = case_match(
      name,
      "poisson_mean" ~ "Poisson Model",
      "zi_poisson_mean" ~ "Zero-Inflated Poisson Model",
      "poisson_unstructured_re_mean" ~ "Poisson Model + Unstructured Random Effects",
      "zi_poisson_unstructured_re_mean" ~ "Zero-Inflated Poisson Model + Unstructured Random Effects",
      "poisson_unstructured_spatial_re_mean" ~ "Poisson Model + Unstructured and Spatial Random Effects",
      "zi_poisson_unstructured_spatial_re_mean" ~ "Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects"
    )
  ) %>%
  select(Model, dic, waic) %>%
  pivot_longer(cols = c(dic, waic),
               names_to = "Metric",
               values_to = "Value") %>%
  pivot_wider(names_from = Model, values_from = Value) %>%
  mutate(Metric = toupper(Metric)) %>%
  mutate(Outcome = "All Injury Crashes") %>%
  select(Outcome, everything())

cyclist_crashes_comparison <- model_selection_cyclist %>%
  mutate(
    Model = case_match(
      name,
      "poisson_mean" ~ "Poisson Model",
      "zi_poisson_mean" ~ "Zero-Inflated Poisson Model",
      "poisson_unstructured_re_mean" ~ "Poisson Model + Unstructured Random Effects",
      "zi_poisson_unstructured_re_mean" ~ "Zero-Inflated Poisson Model + Unstructured Random Effects",
      "poisson_unstructured_spatial_re_mean" ~ "Poisson Model + Unstructured and Spatial Random Effects",
      "zi_poisson_unstructured_spatial_re_mean" ~ "Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects"
    )
  ) %>%
  select(Model, dic, waic) %>%
  pivot_longer(cols = c(dic, waic),
               names_to = "Metric",
               values_to = "Value") %>%
  pivot_wider(names_from = Model, values_from = Value) %>%
  mutate(Metric = toupper(Metric)) %>%
  mutate(Outcome = "Cyclist Involved Injury Crashes") %>%
  select(Outcome, everything())

pedestrian_crashes_comparison <- model_selection_pedestrian %>%
  mutate(
    Model = case_match(
      name,
      "poisson_mean" ~ "Poisson Model",
      "zi_poisson_mean" ~ "Zero-Inflated Poisson Model",
      "poisson_unstructured_re_mean" ~ "Poisson Model + Unstructured Random Effects",
      "zi_poisson_unstructured_re_mean" ~ "Zero-Inflated Poisson Model + Unstructured Random Effects",
      "poisson_unstructured_spatial_re_mean" ~ "Poisson Model + Unstructured and Spatial Random Effects",
      "zi_poisson_unstructured_spatial_re_mean" ~ "Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects"
    )
  ) %>%
  select(Model, dic, waic) %>%
  pivot_longer(cols = c(dic, waic),
               names_to = "Metric",
               values_to = "Value") %>%
  pivot_wider(names_from = Model, values_from = Value) %>%
  mutate(Metric = toupper(Metric)) %>%
  mutate(Outcome = "Pedestrian Involved Injury Crashes") %>%
  select(Outcome, everything())

# Create a new Word document
doc_sm2 <- read_docx(path = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Supplementary Material/sm_template_2.docx")

word_size <- docx_dim(doc_sm2)

width <- word_size$page['width'] - word_size$margins['left'] - word_size$margins['right']
height <- word_size$page['height'] - word_size$margins['top'] - word_size$margins['bottom']

st1 <- bind_rows(
  all_crashes_comparison,
  cyclist_crashes_comparison,
  pedestrian_crashes_comparison
) %>%
  flextable() %>%
  theme_booktabs() %>%
  hline(i = c(2, 4), part = "body") %>%
  bg(j = 3:4,
     bg = "grey95",
     part = "all") %>%
  bg(j = 7:8,
     bg = "grey95",
     part = "all") %>%
  merge_v(j = ~ Outcome) %>%
  set_caption(
    "Table 1. Model comparison for Poisson and Zero-Inflated Poisson with and without unstructured and spatial random effects. All models were fit with a VanDIX and Region interaction as fixed effects. Poisson models fit all injury crash models better when incorporating random effects at dissemination area level, while zero-inflated poisson models fit cyclist and pedestrian injury crash models better across all specifications. "
  ) %>%
  fontsize(size = 10) %>%
  fit_to_width(max_width = width)

st1


```


### Table 2 - All Injury Crashes

```{r model details all}

st2 <- all_crashes_full_model_details %>%
  add_row(term = "Fixed Effects", .before = 1) %>%
  add_row(term = "Hyper Parameters", .before = 39) %>%
  add_row(term = "Model Fit", .before = 42) %>%
  select(-parameter_type) %>%
  mutate(across(where(is.numeric), ~ round(., 3))) %>%
  flextable() %>%
  hline(i = c(1, 38, 39, 41, 42), part = "body") %>%
  set_header_labels(values = c("Term", rep(
    c(
      "Posterior Mean",
      "Lower 95% Credible Interval",
      "Upper 95% Credible Interval"
    ),
    5
  ))) %>%
  add_header_row(
    values = c(
      "",
      "Unadjusted Poisson Model",
      "Unadjusted Poisson Model + Unstructured Random Effects",
      "Unadjusted Poisson Model + Unstructured and Spatial Random Effects",
      "Minimally Adjusted Poisson Model + Unstructured and Spatial Random Effects",
      "Adjusted Poisson Model + Unstructured and Spatial Random Effects"
    ),
    colwidths = c(1, 3, 3, 3, 3, 3)
  ) %>%
  bg(j = 2:4,
     bg = "grey95",
     part = "all") %>%
  bg(j = 8:10,
     bg = "grey95",
     part = "all") %>%
  bg(j = 14:16,
     bg = "grey95",
     part = "all") %>%
  set_caption(
    "Table 2. Model parameter estimates across five model specifications for all injury crashes."
  ) %>%
  fontsize(size = 9)

st2


```

The parameter sigma, the overall variance of the combined random effects term was exp(0.8) = 2.2, indicating substantial overall variance. Nearly half of that variance, parameter rho, was spatially structured exp(0.4) = 49%.

### Table 3 -  Cyclist Involved Injury Crashes

```{r model details cyclist}

st3 <- cyclist_crashes_full_model_details %>%
  add_row(term = "Fixed Effects", .before = 1) %>%
  add_row(term = "Hyper Parameters", .before = 39) %>%
  add_row(term = "Model Fit", .before = 43) %>%
  select(-parameter_type) %>%
  mutate(across(where(is.numeric), ~ round(., 3))) %>%
  flextable() %>%
  hline(i = c(1, 38, 39, 42, 43), part = "body") %>%
  set_header_labels(values = c("Term", rep(
    c(
      "Posterior Mean",
      "Lower 95% Credible Interval",
      "Upper 95% Credible Interval"
    ),
    5
  ))) %>%
  add_header_row(
    values = c(
      "",
      "Unadjusted Zero-Inflated Poisson Model",
      "Unadjusted Zero-Inflated Poisson Model + Unstructured Random Effects",
      "Unadjusted Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects",
      "Minimally Adjusted Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects",
      "Adjusted Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects"
    ),
    colwidths = c(1, 3, 3, 3, 3, 3)
  ) %>%
  bg(j = 2:4,
     bg = "grey95",
     part = "all") %>%
  bg(j = 8:10,
     bg = "grey95",
     part = "all") %>%
  bg(j = 14:16,
     bg = "grey95",
     part = "all") %>%
  set_caption(
    "Table 3. Model parameter estimates across five model specifications for cyclist involved injury crashes."
  ) %>%
  fontsize(size = 9)

st3

```

### Table 4 - Pedestrian Involved Injury Crashes

```{r model details pedestrian}

st4 <- pedestrian_crashes_full_model_details %>%
  add_row(term = "Fixed Effects", .before = 1) %>%
  add_row(term = "Hyper Parameters", .before = 39) %>%
  add_row(term = "Model Fit", .before = 43) %>%
  select(-parameter_type) %>%
  mutate(across(where(is.numeric), ~ round(., 3))) %>%
  flextable() %>%
  hline(i = c(1, 38, 39, 42, 43), part = "body") %>%
  set_header_labels(values = c("Term", rep(
    c(
      "Posterior Mean",
      "Lower 95% Credible Interval",
      "Upper 95% Credible Interval"
    ),
    5
  ))) %>%
  add_header_row(
    values = c(
      "",
      "Unadjusted Zero-Inflated Poisson Model",
      "Unadjusted Zero-Inflated Poisson Model + Unstructured Random Effects",
      "Unadjusted Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects",
      "Minimally Adjusted Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects",
      "Adjusted Zero-Inflated Poisson Model + Unstructured and Spatial Random Effects"
    ),
    colwidths = c(1, 3, 3, 3, 3, 3)
  ) %>%
  bg(j = 2:4,
     bg = "grey95",
     part = "all") %>%
  bg(j = 8:10,
     bg = "grey95",
     part = "all") %>%
  bg(j = 14:16,
     bg = "grey95",
     part = "all") %>%
  set_caption(
    "Table 4. Model parameter estimates across five model specifications for pedestrian involved injury crashes."
  ) %>%
  fontsize(size = 9)
st4
```


```{r}
doc_sm2 <- doc_sm2 %>%
    body_add_gg(value = vandix_distribution,
                height = 9.45,
                width = 7.48,
                res = 300) %>%
    body_end_section_portrait() %>% 
  body_add_flextable(value = st1) %>%
  body_add_par(value = "") %>%  # Adds an empty paragraph for spacing
  body_add_par(value = "") %>%  # Adding multiple paragraphs increases the space
  body_add_break() %>%
  
  body_add_flextable(value = st2) %>%
  body_add_par(value = "") %>%
  body_add_par(value = "") %>%
  body_add_break() %>%
  
  body_add_flextable(value = st3) %>%
  body_add_par(value = "") %>%
  body_add_par(value = "") %>%
  body_add_break() %>%
  
  body_add_flextable(value = st4) %>%
  body_add_par(value = "") %>%
  body_add_par(value = "") %>% 
  body_end_section_landscape()
# Save the document
print(doc_sm2, target = "C:/Users/micha/Documents/GitHub/Area-Level-Deprivation-Traffic-Injury/Supplementary Material/Supplementary Material 2 - raw.docx")

```

# Reproducibility Receipt

```{r,	echo = FALSE, message = FALSE, warning = FALSE}
rt <- tictoc::toc(quiet = TRUE)
paste0("Total run time: ", round(rt$toc / 60, 2), " minutes")
## datetime
Sys.time()

## repository
git2r::repository()

## Session info
sessionInfo()
```
